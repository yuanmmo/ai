<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>WebAR 粒子互动系统</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
            color: #fff;
        }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 1.2em;
            text-align: center;
            transition: opacity 0.5s ease-out;
        }
        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #loading-screen p {
            margin-top: 20px;
        }
        #loading-screen button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 30px;
            transition: background-color 0.3s ease;
        }
        #loading-screen button:hover {
            background-color: #0056b3;
        }
        #webcam-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* 镜像翻转，符合自拍习惯 */
            z-index: -1; /* 确保在 canvas 之下 */
            display: none; /* 初始隐藏，MediaPipe 会使用它 */
        }
        #threejs-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 1;
        }
        #gesture-display {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            font-size: 1.1em;
            z-index: 10;
        }
    </style>
    <!-- Three.js CDN (unpkg.com 兼容性好) -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <!-- MediaPipe Hands CDN (jsdelivr.net 兼容性好) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675466838/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1673567034/camera_utils.js"></script>
</head>
<body>
    <div id="loading-screen">
        <h1>WebAR 粒子互动系统</h1>
        <p>正在加载模型和请求摄像头权限...</p>
        <p>请确保您的浏览器支持 WebGL 和摄像头访问。</p>
        <button id="startButton" style="display:none;">开始体验</button>
    </div>

    <video id="webcam-video" autoplay playsinline></video>
    <canvas id="threejs-canvas"></canvas>
    <div id="gesture-display">当前手势: 无</div>

    <script>
        // --- 全局变量 ---
        let scene, camera, renderer, clock;
        let particles, geometry, material;
        const particleCount = 6000;
        const particlePositions = new Float32Array(particleCount * 3);
        const particleColors = new Float32Array(particleCount * 3);
        const particleSizes = new Float32Array(particleCount);

        const particlesData = []; // 存储每个粒子的物理属性
        const tempVec3 = new THREE.Vector3(); // 临时向量，减少GC

        let hands, cameraUtil;
        let videoElement;
        let lastHandLandmarks = null;
        let currentGesture = 'none';
        let lastGesture = 'none';
        let gestureTransitionProgress = 1; // 0-1, 1表示完成
        const transitionDuration = 0.5; // 过渡动画时长 (秒)
        const transitionExplosionForce = 20; // 过渡时的粒子爆炸力

        // 物理参数
        const springConstant = 5; // 弹簧常数，粒子拉向目标位置的强度
        const dampingFactor = 0.9; // 阻尼系数，粒子速度衰减
        const maxVelocity = 50; // 最大速度，防止粒子飞太快

        // 交互参数
        let lastHandCenter = new THREE.Vector3();
        let handVelocity = new THREE.Vector3();
        const waveThreshold = 0.05; // 挥手速度阈值 (归一化屏幕坐标)
        const waveForce = 100; // 挥手吹散粒子强度
        let isWaving = false;

        // 深度推拉参数
        const minHandScale = 0.05; // 最小手掌相对屏幕大小
        const maxHandScale = 0.5;  // 最大手掌相对屏幕大小
        const minCameraZ = 10;
        const maxCameraZ = 40;
        let targetCameraZ = 20; // 默认相机Z

        const gestureDisplay = document.getElementById('gesture-display');
        const loadingScreen = document.getElementById('loading-screen');
        const startButton = document.getElementById('startButton');

        // --- 初始化 Three.js 场景 ---
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = targetCameraZ;

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('threejs-canvas'), alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            clock = new THREE.Clock();

            // 创建粒子几何体
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));

            // 创建粒子材质
            material = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: new THREE.TextureLoader().load('https://unpkg.com/three@0.158.0/examples/textures/sprites/spark1.png') }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4(vColor, 1.0 - length(gl_PointCoord - vec2(0.5))); // 圆形渐变
                        gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord); // 叠加纹理
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 初始化粒子数据
            for (let i = 0; i < particleCount; i++) {
                const x = (Math.random() - 0.5) * 20;
                const y = (Math.random() - 0.5) * 20;
                const z = (Math.random() - 0.5) * 20;
                particlePositions[i * 3] = x;
                particlePositions[i * 3 + 1] = y;
                particlePositions[i * 3 + 2] = z;

                const color = new THREE.Color();
                color.setHSL(Math.random(), 1.0, 0.5); // 随机颜色
                particleColors[i * 3] = color.r;
                particleColors[i * 3 + 1] = color.g;
                particleColors[i * 3 + 2] = color.b;

                particleSizes[i] = 1 + Math.random() * 2; // 随机大小

                particlesData.push({
                    position: new THREE.Vector3(x, y, z),
                    velocity: new THREE.Vector3(),
                    acceleration: new THREE.Vector3(),
                    color: color,
                    size: particleSizes[i],
                    targetPosition: new THREE.Vector3(x, y, z), // 初始目标位置就是当前位置
                    originalPosition: new THREE.Vector3(x, y, z), // 用于过渡时的原始位置
                    lifetime: Math.random() * 2 + 1, // 用于烟花效果
                    age: 0,
                    isFirework: false
                });
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            geometry.attributes.size.needsUpdate = true;

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MediaPipe Hands 初始化 ---
        async function initMediaPipe() {
            videoElement = document.getElementById('webcam-video');

            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675466838/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onResults);

            cameraUtil = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 1280, // 视频分辨率
                height: 720
            });

            try {
            await cameraUtil.start();
                console.log("Camera started.");
                startButton.style.display = 'block'; // 显示开始按钮
                loadingScreen.querySelector('p').innerText = "摄像头已就绪，点击开始体验。";
                startButton.onclick = () => {
                    loadingScreen.classList.add('hidden');
                    // 确保视频在开始后可见，MediaPipe需要
                    videoElement.style.display = 'block';
                    animate(); // 启动动画循环
                };
            } catch (error) {
                console.error("Failed to start camera:", error);
                loadingScreen.querySelector('p').innerText = "无法启动摄像头，请检查权限或设备。";
            }
        }

        // --- MediaPipe 结果处理 ---
        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                lastHandLandmarks = null;
                updateGesture('none');
                return;
            }

            const landmarks = results.multiHandLandmarks[0]; // 只处理第一只手
            updateHandInteraction(landmarks);
            detectGesture(landmarks);
            lastHandLandmarks = landmarks;
        }

        // --- 手势检测逻辑 ---
        function getFingerCurl(tip, pip, dip, mcp) {
            // 计算指尖到掌骨的距离，与指尖到近端指节的距离比较
            const tipToMcp = new THREE.Vector3(tip.x - mcp.x, tip.y - mcp.y, tip.z - mcp.z).length();
            const tipToPip = new THREE.Vector3(tip.x - pip.x, tip.y - pip.y, tip.z - pip.z).length();
            return tipToPip / tipToMcp; // 越小越弯曲
        }

        const FINGER_TIPS = [8, 12, 16, 20]; // 食指、中指、无名指、小指尖
        const FINGER_PIPS = [6, 10, 14, 18]; // 食指、中指、无名指、小指近端指节
        const FINGER_DIPS = [7, 11, 15, 19]; // 食指、中指、无名指、小指远端指节
        const FINGER_MCPS = [5, 9, 13, 17]; // 食指、中指、无名指、小指掌骨

        function detectGesture(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];

            const thumbCurl = getFingerCurl(landmarks[4], landmarks[3], landmarks[2], landmarks[1]);
            const indexCurl = getFingerCurl(landmarks[8], landmarks[7], landmarks[6], landmarks[5]);
            const middleCurl = getFingerCurl(landmarks[12], landmarks[11], landmarks[10], landmarks[9]);
            const ringCurl = getFingerCurl(landmarks[16], landmarks[15], landmarks[14], landmarks[13]);
            const pinkyCurl = getFingerCurl(landmarks[20], landmarks[19], landmarks[18], landmarks[17]);

            const curlThreshold = 0.6; // 弯曲阈值，小于此值认为弯曲

            let detected = 'none';

            // 判断张手 (所有手指伸直)
            if (thumbCurl > curlThreshold && indexCurl > curlThreshold && middleCurl > curlThreshold && ringCurl > curlThreshold && pinkyCurl > curlThreshold) {
                detected = 'open_hand';
            }
            // 判断剪刀手 (食指和中指伸直，其他弯曲)
            else if (indexCurl > curlThreshold && middleCurl > curlThreshold && thumbCurl < curlThreshold && ringCurl < curlThreshold && pinkyCurl < curlThreshold) {
                detected = 'scissors';
            }
            // 判断握拳 (所有手指弯曲)
            else if (thumbCurl < curlThreshold && indexCurl < curlThreshold && middleCurl < curlThreshold && ringCurl < curlThreshold && pinkyCurl < curlThreshold) {
                detected = 'fist';
            }
            // 判断食指 (食指伸直，其他弯曲)
            else if (indexCurl > curlThreshold && thumbCurl < curlThreshold && middleCurl < curlThreshold && ringCurl < curlThreshold && pinkyCurl < curlThreshold) {
                detected = 'index_finger';
            }
            // 判断竖大拇指 (大拇指伸直，其他弯曲)
            else if (thumbCurl > curlThreshold && indexCurl < curlThreshold && middleCurl < curlThreshold && ringCurl < curlThreshold && pinkyCurl < curlThreshold) {
                detected = 'thumb_up';
            }

            updateGesture(detected);
        }

        function updateGesture(newGesture) {
            if (newGesture !== currentGesture) {
                lastGesture = currentGesture;
                currentGesture = newGesture;
                gestureTransitionProgress = 0; // 重置过渡进度
                gestureDisplay.innerText = `当前手势: ${getGestureName(currentGesture)}`;
                console.log("Gesture changed to:", newGesture);

                // 如果是烟花手势，需要重置所有粒子的烟花状态
                if (newGesture !== 'index_finger') {
                    particlesData.forEach(p => p.isFirework = false);
                }
            }
        }

        function getGestureName(gesture) {
            switch (gesture) {
                case 'open_hand': return '张手 (行星)';
                case 'scissors': return '剪刀手 (文字)';
                case 'fist': return '握拳 (圆环)';
                case 'index_finger': return '食指 (烟花)';
                case 'thumb_up': return '竖大拇指 (爱心)';
                default: return '无';
            }
        }

        // --- 粒子形状生成函数 ---

        // 生成球体上的点
        function generateSpherePoints(radius, center) {
            const positions = [];
            for (let i = 0; i < particleCount / 2; i++) { // 一半粒子用于球体
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const x = center.x + radius * Math.sin(phi) * Math.cos(theta);
                const y = center.y + radius * Math.sin(phi) * Math.sin(theta);
                const z = center.z + radius * Math.cos(phi);
                positions.push(new THREE.Vector3(x, y, z));
            }
            return positions;
        }

        // 生成环形上的点
        function generateRingPoints(innerRadius, outerRadius, center, normal = new THREE.Vector3(0, 1, 0)) {
            const positions = [];
            const count = particleCount / 2; // 一半粒子用于环
            for (let i = 0; i < count; i++) {
                const r = innerRadius + Math.random() * (outerRadius - innerRadius);
                const theta = Math.random() * Math.PI * 2;
                const x = center.x + r * Math.cos(theta);
                const y = center.y + r * Math.sin(theta);
                const z = center.z; // 假设在XY平面

                // 如果需要旋转环，可以应用旋转矩阵
                // 暂时简化为XY平面
                positions.push(new THREE.Vector3(x, y, z));
            }
            return positions;
        }

        // 生成文字形状的点 (Canvas 采样)
        function generateTextShape(text, scale = 0.03) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = 120;
            canvas.width = 1024;
            canvas.height = 256; // 调整高度以适应文字

            ctx.fillStyle = 'black'; // 背景色，用于清除
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = `bold ${fontSize}px "Noto Sans SC", sans-serif`; // 优先使用思源黑体
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const positions = [];
            const density = 4; // 采样密度，值越大粒子越少

            for (let y = 0; y < canvas.height; y += density) {
                for (let x = 0; x < canvas.width; x += density) {
                    const alpha = imageData.data[((y * canvas.width + x) * 4) + 3];
                    if (alpha > 128) { // 如果像素不透明
                        // 映射到 Three.js 坐标系，中心化
                        positions.push(new THREE.Vector3(
                            (x - canvas.width / 2) * scale,
                            (canvas.height / 2 - y) * scale,
                            0
                        ));
                    }
                }
            }
            return positions;
        }

        // 生成心形形状的点 (参数方程)
        function generateHeartShape(scale = 1) {
            const positions = [];
            const numPoints = particleCount;
            for (let i = 0; i < numPoints; i++) {
                const t = (i / numPoints) * Math.PI * 2; // 0 到 2PI
                const x = 16 * Math.pow(Math.sin(t), 3) * scale;
                const y = (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) * scale;
                const z = (Math.random() - 0.5) * scale * 0.5; // 增加一点深度
                positions.push(new THREE.Vector3(x, y, z));
            }
            return positions;
        }


        // --- 更新粒子目标位置 ---
        const rotationAxis = new THREE.Vector3(0, 1, 0).normalize(); // 行星环绕轴
        let planetRotationAngle = 0; // 行星旋转角度

        function updateParticleTargets(deltaTime) {
            const handWorldPos = new THREE.Vector3(); // 归一化手部坐标转换为世界坐标
            if (lastHandLandmarks) {
                // 使用手腕作为中心点，并转换为世界坐标
                const wrist = lastHandLandmarks[0];
                handWorldPos.set((wrist.x - 0.5) * 2 * (camera.aspect > 1 ? camera.aspect : 1), (0.5 - wrist.y) * 2 * (camera.aspect < 1 ? 1/camera.aspect : 1), -1); // Z值假定在屏幕前
                handWorldPos.unproject(camera); // 转换为世界坐标
            } else {
                handWorldPos.set(0, 0, 0); // 没有手时，默认中心
            }

            // 平滑相机Z轴
            camera.position.z += (targetCameraZ - camera.position.z) * 0.1;


            if (gestureTransitionProgress < 1) {
                gestureTransitionProgress += deltaTime / transitionDuration;
                gestureTransitionProgress = Math.min(gestureTransitionProgress, 1);
            }

            let targetShapePositions = [];
            let currentShapePositions = []; // 用于过渡时计算当前形状的粒子位置

            // 根据当前手势生成目标形状
            switch (currentGesture) {
                case 'open_hand': // 行星带星环
                    const planetRadius = 3;
                    const ringInnerRadius = 5;
                    const ringOuterRadius = 7;
                    targetShapePositions = targetShapePositions.concat(generateSpherePoints(planetRadius, handWorldPos));
                    targetShapePositions = targetShapePositions.concat(generateRingPoints(ringInnerRadius, ringOuterRadius, handWorldPos));
                    planetRotationAngle += deltaTime * 0.5; // 行星旋转速度
                    break;
                case 'scissors': // 文字
                    targetShapePositions = generateTextShape("我是 元默");
                    break;
                case 'fist': // 圆环
                    targetShapePositions = generateRingPoints(3, 5, handWorldPos, new THREE.Vector3(0, 0, 1)); // 垂直于屏幕的环
                    break;
                case 'thumb_up': // 爱心
                    targetShapePositions = generateHeartShape(0.5); // 调整大小
                    break;
                case 'index_finger': // 烟花 (特殊处理，粒子会动态生成/销毁)
                    // 粒子目标位置保持不变，或者随机散开
                    // 烟花效果在粒子更新循环中直接处理
                    break;
                default: // 无手势或未知手势，粒子随机散开
                    for (let i = 0; i < particleCount; i++) {
                        targetShapePositions.push(particlesData[i].originalPosition);
                    }
                    break;
            }

            // 更新每个粒子的目标位置
            for (let i = 0; i < particleCount; i++) {
                const p = particlesData[i];

                // 记录当前形状的粒子位置，用于过渡
                currentShapePositions[i] = p.position.clone();

                if (currentGesture === 'index_finger') {
                    // 烟花效果不设定固定目标位置
                    if (!p.isFirework && Math.random() < 0.01 && lastHandLandmarks) { // 随机触发烟花
                        p.isFirework = true;
                        p.age = 0;
                        const indexTipWorld = new THREE.Vector3((lastHandLandmarks[8].x - 0.5) * 2, (0.5 - lastHandLandmarks[8].y) * 2, -1);
                        indexTipWorld.unproject(camera);
                        p.position.copy(indexTipWorld); // 从指尖发射
                        p.velocity.set((Math.random() - 0.5) * 5, 10 + Math.random() * 5, (Math.random() - 0.5) * 5); // 向上发射
                        p.lifetime = 1 + Math.random() * 1;
                        p.size = 2 + Math.random() * 3;
                    }
                    p.targetPosition = null; // 烟花粒子没有固定目标
                } else {
                    p.isFirework = false; // 非烟花手势，取消烟花状态
                    // 将粒子映射到目标形状的点上
                    if (targetShapePositions.length > 0) {
                        const targetIdx = i % targetShapePositions.length;
                        p.targetPosition = targetShapePositions[targetIdx].clone();

                        // 如果是行星，应用旋转
                        if (currentGesture === 'open_hand') {
                            const center = handWorldPos;
                            p.targetPosition.sub(center); // 移到原点
                            p.targetPosition.applyAxisAngle(rotationAxis, planetRotationAngle); // 旋转
                            p.targetPosition.add(center); // 移回中心
                        }
                    } else {
                        p.targetPosition = p.originalPosition; // 默认回到原始位置
                    }
                }
            }

            // 处理过渡效果
            if (gestureTransitionProgress < 1 && lastGesture !== 'none' && currentGesture !== 'none') {
                for (let i = 0; i < particleCount; i++) {
                    const p = particlesData[i];
                    // 在过渡开始时，给粒子一个短暂的向外爆炸力
                    if (gestureTransitionProgress < 0.1) {
                        const direction = p.position.clone().sub(handWorldPos).normalize();
                        p.velocity.add(direction.multiplyScalar(transitionExplosionForce * (1 - gestureTransitionProgress)));
                    }
                }
            }
        }

        // --- 交互逻辑 ---
        function updateHandInteraction(landmarks) {
            const wrist = landmarks[0];
            const middleFingerTip = landmarks[12];

            // 1. 挥手风暴检测
            const currentHandCenter = new THREE.Vector3(wrist.x, wrist.y, wrist.z); // 归一化坐标
            if (lastHandLandmarks) {
                handVelocity.subVectors(currentHandCenter, lastHandCenter);
                if (handVelocity.length() > waveThreshold) {
                    isWaving = true;
                } else {
                    isWaving = false;
                }
            }
            lastHandCenter.copy(currentHandCenter);

            // 2. 深度推拉反馈
            // 估算手掌大小：手腕到中指尖的距离
            const handSize = new THREE.Vector3(wrist.x - middleFingerTip.x, wrist.y - middleFingerTip.y, wrist.z - middleFingerTip.z).length();
            const normalizedHandSize = THREE.MathUtils.mapLinear(handSize, minHandScale, maxHandScale, 0, 1);
            targetCameraZ = THREE.MathUtils.mapLinear(normalizedHandSize, 0, 1, maxCameraZ, minCameraZ); // 手越大，Z越小（越近）
            targetCameraZ = THREE.MathUtils.clamp(targetCameraZ, minCameraZ, maxCameraZ);
        }


        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            updateParticleTargets(deltaTime); // 更新粒子目标位置和手势相关逻辑

            // 更新粒子物理
            for (let i = 0; i < particleCount; i++) {
                const p = particlesData[i];

                if (p.isFirework) {
                    // 烟花粒子特殊处理
                    p.age += deltaTime;
                    if (p.age > p.lifetime) {
                        // 重置烟花粒子
                        p.isFirework = false;
                        p.position.copy(p.originalPosition);
                        p.velocity.set(0, 0, 0);
                        p.acceleration.set(0, 0, 0);
                        p.size = 1 + Math.random() * 2;
                        particlesData[i].color.setHSL(Math.random(), 1.0, 0.5); // 随机颜色
                        continue;
                    }

                    // 模拟重力
                    p.acceleration.y = -9.8 * 0.5; // 减小重力影响
                    p.velocity.add(p.acceleration.clone().multiplyScalar(deltaTime));
                    p.velocity.multiplyScalar(0.98); // 阻尼
                    p.position.add(p.velocity.clone().multiplyScalar(deltaTime));

                    // 烟花粒子逐渐变小和透明
                    particleSizes[i] = p.size * (1 - p.age / p.lifetime);
                    p.color.setHSL(p.color.getHSL({}).h, 1.0, 0.5 + (p.age / p.lifetime) * 0.5); // 逐渐变亮
                } else {
                    // 非烟花粒子，遵循弹簧-阻尼模型
                    if (p.targetPosition) {
                        tempVec3.subVectors(p.targetPosition, p.position);
                        p.acceleration.add(tempVec3.multiplyScalar(springConstant));
                    }

                    // 挥手风暴作用力
                    if (isWaving && handVelocity.length() > waveThreshold && lastHandLandmarks) {
                        const wrist = lastHandLandmarks[0];
                        const handCenter3D = new THREE.Vector3((wrist.x - 0.5) * 2, (0.5 - wrist.y) * 2, -1);
                        handCenter3D.unproject(camera); // 转换为世界坐标

                        tempVec3.subVectors(p.position, handCenter3D).normalize();
                        p.acceleration.add(tempVec3.multiplyScalar(waveForce * handVelocity.length()));
                    }

                    p.velocity.add(p.acceleration.clone().multiplyScalar(deltaTime));
                    p.velocity.multiplyScalar(dampingFactor); // 阻尼
                    p.velocity.clampLength(0, maxVelocity); // 限制最大速度
                    p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
                    p.acceleration.set(0, 0, 0); // 重置加速度

                    particleSizes[i] = p.size; // 恢复原始大小
                    particlesData[i].color.copy(p.color); // 恢复原始颜色
                }


                // 更新 BufferAttribute
                particlePositions[i * 3] = p.position.x;
                particlePositions[i * 3 + 1] = p.position.y;
                particlePositions[i * 3 + 2] = p.position.z;

                particleColors[i * 3] = p.color.r;
                particleColors[i * 3 + 1] = p.color.g;
                particleColors[i * 3 + 2] = p.color.b;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            geometry.attributes.size.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // --- 启动函数 ---
        window.onload = () => {
            initThreeJS();
            initMediaPipe();
        };
    </script>
</body>
</html>
