<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebARç²’å­äº’åŠ¨ç³»ç»Ÿ</title>
    <script src="https://unpkg.com/three@0.137.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    <script src="https://unpkg.com/camera-controls@1.36.1/dist/camera-controls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            padding: 15px;
            text-align: center;
            background: rgba(0, 20, 30, 0.8);
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            z-index: 10;
        }
        
        h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
            color: #0ff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }
        
        .subtitle {
            color: #8cf;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        
        #container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #ar-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #video-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 240px;
            height: 180px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            overflow: hidden;
            z-index: 2;
            background: #000;
        }
        
        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 2;
            padding: 0 20px;
        }
        
        .control-panel {
            background: rgba(0, 20, 30, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(5px);
        }
        
        .gesture-info {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        
        .gesture-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 12px;
            border-radius: 6px;
            background: rgba(0, 40, 60, 0.6);
            border: 1px solid transparent;
            transition: all 0.3s;
            min-width: 80px;
        }
        
        .gesture-item.active {
            border-color: #0ff;
            background: rgba(0, 80, 120, 0.7);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .gesture-icon {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .gesture-name {
            font-size: 0.8rem;
            text-align: center;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 2;
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s;
        }
        
        .loader {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(0, 255, 255, 0.2);
            border-top: 5px solid #0ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: #0ff;
            font-size: 1.2rem;
            text-align: center;
        }
        
        #instructions {
            position: absolute;
            bottom: 120px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.9rem;
            color: #8cf;
            padding: 0 20px;
            z-index: 2;
        }
        
        .highlight {
            color: #0ff;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 1.4rem;
            }
            
            #video-container {
                width: 180px;
                height: 135px;
            }
            
            .gesture-item {
                padding: 6px 8px;
                min-width: 70px;
            }
            
            .gesture-icon {
                font-size: 1.2rem;
            }
            
            #instructions {
                font-size: 0.8rem;
                bottom: 140px;
            }
        }
        
        @media (max-width: 480px) {
            #video-container {
                width: 140px;
                height: 105px;
                top: 5px;
                right: 5px;
            }
            
            .control-panel {
                padding: 10px;
            }
            
            .gesture-info {
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>WebAR ç²’å­äº’åŠ¨ç³»ç»Ÿ</h1>
        <div class="subtitle">ä½¿ç”¨ Three.js + MediaPipe Hands | 16000ä¸ªæµä½“ç²’å­ | äº”æ€æ‰‹åŠ¿å˜å½¢</div>
    </div>
    
    <div id="container">
        <div id="canvas-container">
            <canvas id="ar-canvas"></canvas>
        </div>
        
        <div id="video-container">
            <video id="input-video" autoplay playsinline></video>
        </div>
        
        <div id="stats"></div>
        
        <div id="instructions">
            ä¼¸å‡ºæ‰‹æŒè¿›å…¥æ‘„åƒå¤´èŒƒå›´ï¼Œå°è¯•ä¸åŒæ‰‹åŠ¿ï¼š<span class="highlight">å¼ å¼€æ‰‹</span>ã€<span class="highlight">å‰ªåˆ€æ‰‹</span>ã€<span class="highlight">æ¡æ‹³</span>ã€<span class="highlight">é£ŸæŒ‡</span>ã€<span class="highlight">ç«–å¤§æ‹‡æŒ‡</span>
        </div>
        
        <div id="controls">
            <div class="control-panel">
                <div class="gesture-info">
                    <div class="gesture-item" id="gesture-open">
                        <div class="gesture-icon">ğŸ–ï¸</div>
                        <div class="gesture-name">å¼ æ‰‹å˜çƒ</div>
                    </div>
                    <div class="gesture-item" id="gesture-scissors">
                        <div class="gesture-icon">âœŒï¸</div>
                        <div class="gesture-name">å‰ªåˆ€æ‰‹å˜æ–‡å­—</div>
                    </div>
                    <div class="gesture-item" id="gesture-fist">
                        <div class="gesture-icon">âœŠ</div>
                        <div class="gesture-name">æ¡æ‹³å˜åœ†ç¯</div>
                    </div>
                    <div class="gesture-item" id="gesture-point">
                        <div class="gesture-icon">ğŸ‘†</div>
                        <div class="gesture-name">é£ŸæŒ‡å˜æ˜Ÿå½¢</div>
                    </div>
                    <div class="gesture-item" id="gesture-thumb">
                        <div class="gesture-icon">ğŸ‘</div>
                        <div class="gesture-name">ç«–å¤§æ‹‡æŒ‡å˜çˆ±å¿ƒ</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="loading">
            <div class="loader"></div>
            <div class="loading-text">æ­£åœ¨åŠ è½½ç²’å­ç³»ç»Ÿä¸æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...</div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, particles;
        let handDetector = null;
        let particleCount = 16000;
        let particleSystem;
        let particlePositions, particleVelocities, particleAccelerations;
        let targetShape = 'sphere'; // åˆå§‹å½¢çŠ¶ä¸ºçƒä½“
        let previousGesture = null;
        let handSpeed = 0;
        let lastHandPosition = null;
        let lastHandTime = null;
        let handInFrame = false;
        let handSize = 0;
        let particleScale = 1.0;
        let explosionForce = 0;
        let explosionDecay = 0.95;
        let windForce = new THREE.Vector3(0, 0, 0);
        let windDecay = 0.9;
        
        // åˆå§‹åŒ–Three.jsåœºæ™¯
        function initThreeJS() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            scene.fog = new THREE.Fog(0x000022, 10, 50);
            
            // åˆ›å»ºç›¸æœº
            const canvas = document.getElementById('ar-canvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            camera.position.set(0, 0, 15);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x2255aa, 0.3);
            scene.add(ambientLight);
            
            // æ·»åŠ æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0x00ffff, 0.7);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystem();
            
            // çª—å£å¤§å°è°ƒæ•´äº‹ä»¶
            window.addEventListener('resize', onWindowResize);
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
        }
        
        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        function createParticleSystem() {
            // åˆ›å»ºç²’å­å‡ ä½•ä½“
            const geometry = new THREE.BufferGeometry();
            
            // åˆå§‹åŒ–ç²’å­å±æ€§æ•°ç»„
            particlePositions = new Float32Array(particleCount * 3);
            particleVelocities = new Float32Array(particleCount * 3);
            particleAccelerations = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            // åˆå§‹åŒ–ç²’å­ä½ç½®ï¼ˆéšæœºåˆ†å¸ƒåœ¨ä¸€ä¸ªçƒä½“å†…ï¼‰
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // éšæœºä½ç½®ï¼ˆçƒä½“å†…ï¼‰
                const radius = 2 + Math.random() * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                particlePositions[i3 + 2] = radius * Math.cos(phi);
                
                // åˆå§‹é€Ÿåº¦ä¸º0
                particleVelocities[i3] = 0;
                particleVelocities[i3 + 1] = 0;
                particleVelocities[i3 + 2] = 0;
                
                // åˆå§‹åŠ é€Ÿåº¦ä¸º0
                particleAccelerations[i3] = 0;
                particleAccelerations[i3 + 1] = 0;
                particleAccelerations[i3 + 2] = 0;
                
                // è®¾ç½®é¢œè‰²ï¼ˆé’è‰²æ¸å˜ï¼‰
                const hue = 0.5 + Math.random() * 0.1; // é’è‰²èŒƒå›´
                const saturation = 0.7 + Math.random() * 0.3;
                const lightness = 0.4 + Math.random() * 0.3;
                
                const rgb = hslToRgb(hue, saturation, lightness);
                colors[i3] = rgb[0];
                colors[i3 + 1] = rgb[1];
                colors[i3 + 2] = rgb[2];
            }
            
            // è®¾ç½®å‡ ä½•ä½“å±æ€§
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // åˆ›å»ºç²’å­æè´¨
            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }
        
        // HSLè½¬RGBå‡½æ•°
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // ç°è‰²
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [r, g, b];
        }
        
        // åˆå§‹åŒ–MediaPipe Hands
        async function initMediaPipe() {
            // è·å–è§†é¢‘å…ƒç´ 
            const videoElement = document.getElementById('input-video');
            
            // åˆå§‹åŒ–æ‘„åƒå¤´
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                videoElement.srcObject = stream;
            } catch (err) {
                console.error('æ— æ³•è®¿é—®æ‘„åƒå¤´:', err);
                alert('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·ç¡®ä¿å·²æˆäºˆç›¸æœºæƒé™');
                return;
            }
            
            // åˆ›å»ºæ‰‹éƒ¨æ£€æµ‹å™¨
            handDetector = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                }
            });
            
            // é…ç½®æ‰‹éƒ¨æ£€æµ‹å™¨
            handDetector.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            // è®¾ç½®æ‰‹éƒ¨æ£€æµ‹ç»“æœå›è°ƒ
            handDetector.onResults((results) => {
                processHandResults(results);
            });
            
            // å¼€å§‹æ£€æµ‹å¾ªç¯
            async function detectFrame() {
                if (!videoElement.videoWidth) {
                    requestAnimationFrame(detectFrame);
                    return;
                }
                
                await handDetector.send({ image: videoElement });
                requestAnimationFrame(detectFrame);
            }
            
            // å¼€å§‹æ£€æµ‹
            detectFrame();
            
            // éšè—åŠ è½½ç•Œé¢
            setTimeout(() => {
                document.getElementById('loading').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            }, 2000);
        }
        
        // å¤„ç†æ‰‹éƒ¨æ£€æµ‹ç»“æœ
        function processHandResults(results) {
            // æ¸…é™¤ä¹‹å‰çš„æ‰‹åŠ¿çŠ¶æ€
            document.querySelectorAll('.gesture-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ‰‹
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                handInFrame = false;
                return;
            }
            
            handInFrame = true;
            const landmarks = results.multiHandLandmarks[0];
            
            // è®¡ç®—æ‰‹éƒ¨ä¸­å¿ƒä½ç½®å’Œå¤§å°
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            landmarks.forEach(landmark => {
                minX = Math.min(minX, landmark.x);
                maxX = Math.max(maxX, landmark.x);
                minY = Math.min(minY, landmark.y);
                maxY = Math.max(maxY, landmark.y);
            });
            
            const handWidth = maxX - minX;
            const handHeight = maxY - minY;
            handSize = Math.sqrt(handWidth * handWidth + handHeight * handHeight);
            
            // è®¡ç®—æ‰‹éƒ¨ä¸­å¿ƒ
            const handCenter = new THREE.Vector2(
                (minX + maxX) / 2,
                (minY + maxY) / 2
            );
            
            // è®¡ç®—æ‰‹é€Ÿ
            const currentTime = Date.now();
            if (lastHandPosition && lastHandTime) {
                const timeDiff = (currentTime - lastHandTime) / 1000; // è½¬æ¢ä¸ºç§’
                if (timeDiff > 0) {
                    const distance = handCenter.distanceTo(lastHandPosition);
                    handSpeed = distance / timeDiff;
                    
                    // å¦‚æœæ‰‹é€Ÿè¶…è¿‡é˜ˆå€¼ï¼Œè§¦å‘é£æš´æ•ˆæœ
                    if (handSpeed > 5) {
                        // è®¡ç®—æŒ¥åŠ¨æ–¹å‘
                        const direction = new THREE.Vector2(
                            handCenter.x - lastHandPosition.x,
                            handCenter.y - lastHandPosition.y
                        ).normalize();
                        
                        // å°†2Dæ–¹å‘è½¬æ¢ä¸º3Dé£åŠ›
                        windForce.x = direction.x * handSpeed * 0.5;
                        windForce.y = -direction.y * handSpeed * 0.5; // Yè½´åå‘
                        windForce.z = 0;
                    }
                }
            }
            
            lastHandPosition = handCenter;
            lastHandTime = currentTime;
            
            // è¯†åˆ«æ‰‹åŠ¿
            const gesture = recognizeGesture(landmarks);
            
            // æ›´æ–°UIæ˜¾ç¤ºå½“å‰æ‰‹åŠ¿
            if (gesture) {
                document.getElementById(`gesture-${gesture}`).classList.add('active');
                
                // å¦‚æœæ‰‹åŠ¿å‘ç”Ÿå˜åŒ–ï¼Œè§¦å‘çˆ†ç‚¸æ•ˆæœ
                if (gesture !== previousGesture) {
                    triggerExplosion();
                    previousGesture = gesture;
                }
                
                // æ ¹æ®æ‰‹åŠ¿è®¾ç½®ç›®æ ‡å½¢çŠ¶
                switch (gesture) {
                    case 'open':
                        targetShape = 'sphere';
                        break;
                    case 'scissors':
                        targetShape = 'text';
                        break;
                    case 'fist':
                        targetShape = 'torus';
                        break;
                    case 'point':
                        targetShape = 'star';
                        break;
                    case 'thumb':
                        targetShape = 'heart';
                        break;
                }
            }
        }
        
        // æ‰‹åŠ¿è¯†åˆ«å‡½æ•°
        function recognizeGesture(landmarks) {
            // è·å–å…³é”®ç‚¹
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];
            
            // è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
            const distance = (tip) => {
                return Math.sqrt(
                    Math.pow(tip.x - wrist.x, 2) +
                    Math.pow(tip.y - wrist.y, 2) +
                    Math.pow(tip.z - wrist.z, 2)
                );
            };
            
            const thumbDistance = distance(thumbTip);
            const indexDistance = distance(indexTip);
            const middleDistance = distance(middleTip);
            const ringDistance = distance(ringTip);
            const pinkyDistance = distance(pinkyTip);
            
            // è®¡ç®—å¹³å‡è·ç¦»
            const avgDistance = (thumbDistance + indexDistance + middleDistance + ringDistance + pinkyDistance) / 5;
            
            // åˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ï¼ˆè·ç¦»å¤§äºå¹³å‡è·ç¦»çš„0.8å€ï¼‰
            const isThumbExtended = thumbDistance > avgDistance * 0.8;
            const isIndexExtended = indexDistance > avgDistance * 0.8;
            const isMiddleExtended = middleDistance > avgDistance * 0.8;
            const isRingExtended = ringDistance > avgDistance * 0.8;
            const isPinkyExtended = pinkyDistance > avgDistance * 0.8;
            
            // æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
            const extendedFingers = [isIndexExtended, isMiddleExtended, isRingExtended, isPinkyExtended];
            const extendedCount = extendedFingers.filter(Boolean).length;
            
            // å¼ æ‰‹ï¼šæ‰€æœ‰æ‰‹æŒ‡ä¼¸ç›´
            if (isThumbExtended && extendedCount === 4) {
                return 'open';
            }
            // å‰ªåˆ€æ‰‹ï¼šåªæœ‰é£ŸæŒ‡å’Œä¸­æŒ‡ä¼¸ç›´
            else if (!isThumbExtended && isIndexExtended && isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                return 'scissors';
            }
            // æ¡æ‹³ï¼šæ²¡æœ‰æ‰‹æŒ‡ä¼¸ç›´
            else if (!isThumbExtended && extendedCount === 0) {
                return 'fist';
            }
            // é£ŸæŒ‡ï¼šåªæœ‰é£ŸæŒ‡ä¼¸ç›´
            else if (!isThumbExtended && isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                return 'point';
            }
            // ç«–å¤§æ‹‡æŒ‡ï¼šåªæœ‰å¤§æ‹‡æŒ‡ä¼¸ç›´
            else if (isThumbExtended && extendedCount === 0) {
                return 'thumb';
            }
            
            return null;
        }
        
        // è§¦å‘çˆ†ç‚¸æ•ˆæœ
        function triggerExplosion() {
            explosionForce = 2.0;
            
            // ç»™æ‰€æœ‰ç²’å­æ–½åŠ éšæœºçˆ†ç‚¸åŠ›
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // éšæœºæ–¹å‘
                const dirX = Math.random() * 2 - 1;
                const dirY = Math.random() * 2 - 1;
                const dirZ = Math.random() * 2 - 1;
                
                // å½’ä¸€åŒ–
                const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
                
                // æ–½åŠ çˆ†ç‚¸åŠ›
                particleVelocities[i3] += (dirX / length) * explosionForce;
                particleVelocities[i3 + 1] += (dirY / length) * explosionForce;
                particleVelocities[i3 + 2] += (dirZ / length) * explosionForce;
            }
        }
        
        // è·å–ç›®æ ‡å½¢çŠ¶ä½ç½®
        function getTargetPosition(particleIndex, shape) {
            const i = particleIndex;
            const t = i / particleCount;
            
            switch (shape) {
                case 'sphere':
                    return getSpherePosition(i);
                case 'torus':
                    return getTorusPosition(i);
                case 'star':
                    return getStarPosition(i);
                case 'heart':
                    return getHeartPosition(i);
                case 'text':
                    return getTextPosition(i);
                default:
                    return getSpherePosition(i);
            }
        }
        
        // çƒä½“å½¢çŠ¶
        function getSpherePosition(i) {
            const radius = 5;
            const theta = Math.acos(2 * (i / particleCount) - 1);
            const phi = Math.PI * 2 * i / particleCount * 10;
            
            return {
                x: radius * Math.sin(theta) * Math.cos(phi),
                y: radius * Math.sin(theta) * Math.sin(phi),
                z: radius * Math.cos(theta)
            };
        }
        
        // åœ†ç¯å½¢çŠ¶
        function getTorusPosition(i) {
            const majorRadius = 6;
            const minorRadius = 2;
            const u = (i / particleCount) * Math.PI * 2;
            const v = (i * 10 / particleCount) * Math.PI * 2;
            
            return {
                x: (majorRadius + minorRadius * Math.cos(v)) * Math.cos(u),
                y: (majorRadius + minorRadius * Math.cos(v)) * Math.sin(u),
                z: minorRadius * Math.sin(v)
            };
        }
        
        // æ˜Ÿå½¢å½¢çŠ¶
        function getStarPosition(i) {
            const t = (i / particleCount) * Math.PI * 2;
            const points = 5;
            const outerRadius = 5;
            const innerRadius = 2.5;
            
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = t * points;
            
            return {
                x: radius * Math.cos(angle) * Math.cos(t),
                y: radius * Math.sin(angle) * Math.cos(t),
                z: radius * Math.sin(t)
            };
        }
        
        // å¿ƒå½¢å½¢çŠ¶
        function getHeartPosition(i) {
            const t = (i / particleCount) * Math.PI * 2;
            const scale = 6;
            
            // å¿ƒå½¢å‚æ•°æ–¹ç¨‹
            const x = scale * 16 * Math.pow(Math.sin(t), 3);
            const y = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
            const z = (i / particleCount - 0.5) * 10;
            
            return {
                x: x * 0.01,
                y: -y * 0.01,
                z: z * 0.5
            };
        }
        
        // æ–‡å­—å½¢çŠ¶
        function getTextPosition(i) {
            // é¢„å®šä¹‰çš„æ–‡å­—ä½ç½®ï¼ˆ"æˆ‘æ˜¯ å…ƒé»˜"ï¼‰
            // è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨å¤šä¸ªçƒä½“ç»„åˆæˆæ–‡å­—å½¢çŠ¶
            const segment = Math.floor(i / (particleCount / 6));
            const segmentIndex = i % (particleCount / 6);
            
            let baseX = 0, baseY = 0;
            
            // æ ¹æ®æ–‡å­—çš„ä¸åŒéƒ¨åˆ†è®¾ç½®ä¸åŒä½ç½®
            switch (segment) {
                case 0: // "æˆ‘"
                    baseX = -8;
                    baseY = 0;
                    break;
                case 1: // "æ˜¯"
                    baseX = -4;
                    baseY = 0;
                    break;
                case 2: // ç©ºæ ¼
                    baseX = 0;
                    baseY = 0;
                    break;
                case 3: // "å…ƒ"
                    baseX = 4;
                    baseY = 0;
                    break;
                case 4: // "é»˜"
                    baseX = 8;
                    baseY = 0;
                    break;
                case 5: // è£…é¥°ç²’å­
                    baseX = (Math.random() - 0.5) * 20;
                    baseY = (Math.random() - 0.5) * 10;
                    break;
            }
            
            // åœ¨æ¯ä¸ªæ–‡å­—éƒ¨åˆ†å†…åˆ›å»ºä¸€ä¸ªå°çƒä½“
            const radius = 1.5;
            const theta = Math.acos(2 * (segmentIndex / (particleCount / 6)) - 1);
            const phi = Math.PI * 2 * segmentIndex / (particleCount / 6) * 10;
            
            return {
                x: baseX + radius * Math.sin(theta) * Math.cos(phi),
                y: baseY + radius * Math.sin(theta) * Math.sin(phi),
                z: radius * Math.cos(theta)
            };
        }
        
        // æ›´æ–°ç²’å­ç‰©ç†
        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            
            // æ›´æ–°çˆ†ç‚¸åŠ›
            if (explosionForce > 0.01) {
                explosionForce *= explosionDecay;
            } else {
                explosionForce = 0;
            }
            
            // æ›´æ–°é£åŠ›
            windForce.multiplyScalar(windDecay);
            
            // æ›´æ–°ç²’å­ç¼©æ”¾ï¼ˆåŸºäºæ‰‹éƒ¨å¤§å°ï¼‰
            if (handInFrame) {
                // æ‰‹éƒ¨å¤§å°æ˜ å°„åˆ°ç²’å­ç¼©æ”¾ (0.5 - 2.0)
                particleScale = 0.5 + handSize * 3;
                particleScale = Math.max(0.5, Math.min(particleScale, 2.0));
                
                // æ›´æ–°ç²’å­å¤§å°
                particleSystem.material.size = 0.05 * particleScale;
            }
            
            // æ›´æ–°æ¯ä¸ªç²’å­çš„ç‰©ç†çŠ¶æ€
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // è·å–ç›®æ ‡ä½ç½®
                const targetPos = getTargetPosition(i, targetShape);
                
                // è®¡ç®—å¼¹ç°§åŠ›ï¼ˆæŒ‡å‘ç›®æ ‡ä½ç½®ï¼‰
                const springForce = 0.1;
                const dx = targetPos.x - positions[i3];
                const dy = targetPos.y - positions[i3 + 1];
                const dz = targetPos.z - positions[i3 + 2];
                
                // æ›´æ–°åŠ é€Ÿåº¦ï¼ˆå¼¹ç°§åŠ› + é£åŠ›ï¼‰
                particleAccelerations[i3] = dx * springForce + windForce.x;
                particleAccelerations[i3 + 1] = dy * springForce + windForce.y;
                particleAccelerations[i3 + 2] = dz * springForce + windForce.z;
                
                // æ·»åŠ éšæœºå™ªå£°ï¼Œä½¿ç²’å­æ›´è‡ªç„¶
                const noise = 0.02;
                particleAccelerations[i3] += (Math.random() - 0.5) * noise;
                particleAccelerations[i3 + 1] += (Math.random() - 0.5) * noise;
                particleAccelerations[i3 + 2] += (Math.random() - 0.5) * noise;
                
                // æ›´æ–°é€Ÿåº¦ï¼ˆåŠ é€Ÿåº¦å½±å“ï¼‰
                const damping = 0.95; // é˜»å°¼ç³»æ•°
                particleVelocities[i3] = particleVelocities[i3] * damping + particleAccelerations[i3];
                particleVelocities[i3 + 1] = particleVelocities[i3 + 1] * damping + particleAccelerations[i3 + 1];
                particleVelocities[i3 + 2] = particleVelocities[i3 + 2] * damping + particleAccelerations[i3 + 2];
                
                // æ›´æ–°ä½ç½®ï¼ˆé€Ÿåº¦å½±å“ï¼‰
                positions[i3] += particleVelocities[i3];
                positions[i3 + 1] += particleVelocities[i3 + 1];
                positions[i3 + 2] += particleVelocities[i3 + 2];
            }
            
            // æ ‡è®°å‡ ä½•ä½“éœ€è¦æ›´æ–°
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
        
        // çª—å£å¤§å°è°ƒæ•´å¤„ç†
        function onWindowResize() {
            const canvas = document.getElementById('ar-canvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°ç²’å­ç‰©ç†
            updateParticles();
            
            // è½»å¾®æ—‹è½¬ç›¸æœº
            camera.position.x = Math.sin(Date.now() * 0.0005) * 15;
            camera.position.z = Math.cos(Date.now() * 0.0005) * 15;
            camera.lookAt(0, 0, 0);
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', async () => {
            // åˆå§‹åŒ–Three.js
            initThreeJS();
            
            // åˆå§‹åŒ–MediaPipe Hands
            await initMediaPipe();
            
            // æ·»åŠ æ€§èƒ½ç›‘æ§ï¼ˆå¯é€‰ï¼‰
            // è¿™é‡Œå¯ä»¥æ·»åŠ Stats.jsç­‰æ€§èƒ½ç›‘æ§å·¥å…·
        });
    </script>
</body>
</html>
