<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>WebAR Fluid Particles (CN Optimized)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; touch-action: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        /* è§†é¢‘éœ€è¦å­˜åœ¨ä½†éšè—ï¼Œä¸èƒ½ display:noneï¼Œå¦åˆ™ MediaPipe è¯»ä¸åˆ° */
        #video-input { position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none; z-index: 0; }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; right: 20px; z-index: 10; color: #00ffff;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.8); pointer-events: none;
        }
        .status-box {
            background: rgba(0, 20, 30, 0.6);
            backdrop-filter: blur(4px);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            display: inline-block;
        }
        .loading { font-size: 16px; font-weight: bold; color: #ffeb3b; }
        .loading::after { content: '...'; animation: dot 1.5s infinite; }
        .instruction { font-size: 12px; margin-top: 8px; line-height: 1.6; color: #ccffff; }
        @keyframes dot { 0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; } }
        /* ç§»åŠ¨ç«¯è°ƒæ•´ */
        @media (max-width: 600px) {
            #ui-layer { top: 10px; left: 10px; right: 10px; }
            .instruction { display: none; } /* ç§»åŠ¨ç«¯éšè—æ–‡å­—è¯´æ˜ï¼Œä¿æŒæ¸…çˆ½ */
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="status-box">
        <div id="status" class="loading">æ­£åœ¨è¿æ¥å›½å†…é•œåƒæº</div>
        <div id="fps-counter" style="font-size:12px; color:#aaa; margin-top:5px;"></div>
    </div>
    <div class="instruction">
        ğŸ– å¼ æ‰‹:çƒ | âœŒï¸ å‰ªåˆ€:å­— | âœŠ æ¡æ‹³:ç¯ <br>
        â˜ï¸ é£ŸæŒ‡:æ˜Ÿ | ğŸ‘ æ‹‡æŒ‡:å¿ƒ | ğŸ‘‹ æŒ¥æ‰‹:æ•£
    </div>
</div>

<video id="video-input" playsinline webkit-playsinline></video>
<div id="canvas-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://npm.elemecdn.com/three@0.160.0/build/three.module.js",
            "@mediapipe/hands": "https://npm.elemecdn.com/@mediapipe/hands@0.4.1675469240/hands.js",
            "@mediapipe/camera_utils": "https://npm.elemecdn.com/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { Hands } from '@mediapipe/hands';
    import { Camera } from '@mediapipe/camera_utils';

    // --- ç¯å¢ƒæ£€æµ‹ä¸æ€§èƒ½é€‚é… ---
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    const CONFIG = {
        // ç§»åŠ¨ç«¯é™çº§åˆ° 6000 ç²’å­ï¼ŒPCç«¯ 16000
        particleCount: isMobile ? 6000 : 16000,
        color: 0x00ffff,
        particleSize: isMobile ? 0.25 : 0.15, // ç²’å­å°‘æ—¶ç¨å¾®å˜å¤§ä¸€ç‚¹
        springStrength: 0.05,
        friction: 0.92,
        explosionForce: 0.6,
        stormThreshold: 35,
        stormForce: 2.5,
        baseDepth: isMobile ? 25 : 20
    };

    // --- å˜é‡å®šä¹‰ ---
    let scene, camera, renderer, particlesMesh;
    let targetPositions, currentPositions, velocities;
    let shapeCache = {};
    let currentShape = 'sphere';
    let handLandmarks = null;
    let handSpeed = 0;
    let lastHandPos = new THREE.Vector3();
    let isExploding = false;
    let handSizeFactor = 1;
    let clock = new THREE.Clock();

    const container = document.getElementById('canvas-container');
    const statusEl = document.getElementById('status');
    const fpsEl = document.getElementById('fps-counter');

    // --- 1. Three.js åˆå§‹åŒ– ---
    function initThree() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.baseDepth;

        renderer = new THREE.WebGLRenderer({ 
            antialias: !isMobile, // ç§»åŠ¨ç«¯å…³é—­æŠ—é”¯é½¿ä»¥æé«˜æ€§èƒ½
            alpha: true,
            powerPreference: "high-performance"
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        // é™åˆ¶åƒç´ æ¯”ï¼Œé˜²æ­¢é«˜åˆ†å±æ‰‹æœºå‘çƒ­
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
        container.appendChild(renderer.domElement);

        createParticles();
        precomputeShapes();

        window.addEventListener('resize', onWindowResize);
    }

    // --- 2. ç²’å­ç³»ç»Ÿ ---
    function createParticles() {
        const geometry = new THREE.BufferGeometry();
        currentPositions = new Float32Array(CONFIG.particleCount * 3);
        velocities = new Float32Array(CONFIG.particleCount * 3);
        
        for (let i = 0; i < CONFIG.particleCount * 3; i++) {
            currentPositions[i] = (Math.random() - 0.5) * 50;
            velocities[i] = 0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

        const sprite = generateSprite();
        const material = new THREE.PointsMaterial({
            color: CONFIG.color,
            size: CONFIG.particleSize,
            map: sprite,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        particlesMesh = new THREE.Points(geometry, material);
        scene.add(particlesMesh);
    }

    function generateSprite() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.4, 'rgba(0,255,255,0.5)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true; // ä¿®å¤ï¼šåœ¨è¿™é‡Œè®¾ç½®needsUpdate
        return texture;
    }

    // --- 3. å½¢çŠ¶ç”Ÿæˆ (åŒ…å« Canvas æ–‡å­—ä¼˜åŒ–) ---
    function precomputeShapes() {
        statusEl.textContent = "æ­£åœ¨ç”Ÿæˆ 3D ç‚¹äº‘...";
        
        // å¼‚æ­¥ç”Ÿæˆä»¥é˜²å¡é¡¿ä¸»çº¿ç¨‹
        setTimeout(() => {
            shapeCache.sphere = getSpherePoints(CONFIG.particleCount, 8);
            shapeCache.torus = getTorusPoints(CONFIG.particleCount, 7, 2.5);
            shapeCache.star = getStarPoints(CONFIG.particleCount, 8, 3);
            shapeCache.heart = getHeartPoints(CONFIG.particleCount, 0.5);
            // æ–‡å­—ç”Ÿæˆ
            shapeCache.text = getTextPoints("æˆ‘æ˜¯\nå…ƒé»˜", CONFIG.particleCount);
            
            targetPositions = shapeCache.sphere;
            
            // å½¢çŠ¶ç”Ÿæˆå®Œæ¯•åï¼Œå¯åŠ¨ MediaPipe
            initMediaPipe();
        }, 100);
    }

    function getSpherePoints(count, r) {
        const arr = new Float32Array(count * 3);
        for(let i=0; i<count; i++){
            const phi = Math.acos(-1 + (2*i)/count);
            const theta = Math.sqrt(count * Math.PI) * phi;
            arr[i*3] = r * Math.cos(theta) * Math.sin(phi);
            arr[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
            arr[i*3+2] = r * Math.cos(phi);
        }
        return arr;
    }

    function getTorusPoints(count, R, r) {
        const arr = new Float32Array(count * 3);
        for(let i=0; i<count; i++){
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI * 2;
            arr[i*3] = (R + r*Math.cos(v))*Math.cos(u);
            arr[i*3+1] = (R + r*Math.cos(v))*Math.sin(u);
            arr[i*3+2] = r*Math.sin(v);
        }
        return arr;
    }

    function getHeartPoints(count, s) {
        const arr = new Float32Array(count * 3);
        let i = 0;
        while(i < count) {
            let x = (Math.random()-0.5)*40, y = (Math.random()-0.5)*40, z = (Math.random()-0.5)*40;
            let a = x*x + 2.25*y*y + z*z - 1;
            if(a*a*a - x*x*z*z*z - 0.1125*y*y*z*z*z <= 0) {
                arr[i*3] = x*4*s; arr[i*3+1] = z*4*s+2; arr[i*3+2] = -y*2*s;
                i++;
            }
        }
        return arr;
    }

    function getStarPoints(count, oR, iR) {
        const arr = new Float32Array(count * 3);
        for(let i=0; i<count; i++){
            const t = Math.random() * Math.PI * 2;
            const k = 5;
            // ç®€å•çš„èƒ–äº”è§’æ˜Ÿæ¨¡æ‹Ÿ
            const r = oR * (Math.cos(k * t) + 2.5) / 3.5; 
            arr[i*3] = r * Math.cos(t) * 2;
            arr[i*3+1] = r * Math.sin(t) * 2;
            arr[i*3+2] = (Math.random()-0.5) * 1.5;
        }
        return arr;
    }

    function getTextPoints(text, count) {
        const size = 256; // è¿›ä¸€æ­¥é™ä½åˆ†è¾¨ç‡ä»¥åŠ å¿«ç§»åŠ¨ç«¯å¤„ç†
        const cvs = document.createElement('canvas');
        cvs.width = size; cvs.height = size;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,size,size);
        ctx.fillStyle = '#fff'; 
        ctx.font = 'bold 80px "Microsoft YaHei", sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        
        const lines = text.split('\n');
        const lineHeight = 90;
        const totalHeight = (lines.length - 1) * lineHeight;
        lines.forEach((l, i) => ctx.fillText(l, size/2, size/2 - totalHeight/2 + i * lineHeight));
        
        const data = ctx.getImageData(0,0,size,size).data;
        const pixels = [];
        for(let y=0; y<size; y+=2) {
            for(let x=0; x<size; x+=2) {
                if(data[(y*size+x)*4] > 128) pixels.push({x:(x-size/2)/12, y:-(y-size/2)/12});
            }
        }
        
        const arr = new Float32Array(count*3);
        if (pixels.length === 0) return arr;
        
        for(let i=0; i<count; i++) {
            const p = pixels[i % pixels.length];
            arr[i*3] = p.x + (Math.random()-0.5)*0.2;
            arr[i*3+1] = p.y + (Math.random()-0.5)*0.2;
            arr[i*3+2] = (Math.random()-0.5);
        }
        return arr;
    }

    // --- 4. åŠ¨ç”»å¾ªç¯ ---
    function animate() {
        requestAnimationFrame(animate);

        const pos = particlesMesh.geometry.attributes.position.array;
        let handX = 9999, handY = 9999;
        let isStorming = false;

        if (handLandmarks) {
            const palm = handLandmarks[9];
            const aspect = window.innerWidth / window.innerHeight;
            // å¢åŠ ç§»åŠ¨ç«¯çš„æ‰‹åŠ¿çµæ•åº¦åŒºåŸŸ
            handX = (0.5 - palm.x) * 30 * aspect;
            handY = (0.5 - palm.y) * 30;
            
            if (handSpeed > CONFIG.stormThreshold) isStorming = true;
        }

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const idx = i * 3;
            let px = pos[idx], py = pos[idx+1], pz = pos[idx+2];
            let vx = velocities[idx], vy = velocities[idx+1], vz = velocities[idx+2];

            let tx = targetPositions[idx] * handSizeFactor;
            let ty = targetPositions[idx+1] * handSizeFactor;
            let tz = targetPositions[idx+2] * handSizeFactor;

            let ax = (tx - px) * CONFIG.springStrength;
            let ay = (ty - py) * CONFIG.springStrength;
            let az = (tz - pz) * CONFIG.springStrength;

            if (isStorming) {
                const dx = px - handX, dy = py - handY;
                const d2 = dx*dx + dy*dy;
                if (d2 < 80) {
                    const f = CONFIG.stormForce / (d2 + 0.1);
                    ax += dx * f * 3;
                    ay += dy * f * 3;
                    az += (Math.random()-0.5) * f * 10;
                }
            }

            if (isExploding) {
                vx += (Math.random()-0.5) * CONFIG.explosionForce * 15;
                vy += (Math.random()-0.5) * CONFIG.explosionForce * 15;
                vz += (Math.random()-0.5) * CONFIG.explosionForce * 15;
            }

            vx += ax; vy += ay; vz += az;
            vx *= CONFIG.friction; vy *= CONFIG.friction; vz *= CONFIG.friction;
            
            pos[idx] += vx; pos[idx+1] += vy; pos[idx+2] += vz;
            velocities[idx] = vx; velocities[idx+1] = vy; velocities[idx+2] = vz;
        }

        if(isExploding) isExploding = false;
        particlesMesh.geometry.attributes.position.needsUpdate = true;
        
        // æ—‹è½¬
        particlesMesh.rotation.y += 0.002;

        renderer.render(scene, camera);
    }

    // --- 5. MediaPipe Hands (å›½å†…é•œåƒç‰ˆ) ---
    async function initMediaPipe() {
        statusEl.textContent = "åŠ è½½ AI æ¨¡å‹ (å›½å†…æº)...";
        statusEl.style.color = "#00ffff";

        try {
            // å…³é”®ï¼šå¼ºåˆ¶æŒ‡å®š locateFile åˆ°å›½å†… npmmirror é•œåƒ
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://npm.elemecdn.com/@mediapipe/hands@0.4.1675469240/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1, // 0æ€§èƒ½æœ€å¥½ï¼Œ1ç²¾åº¦å¹³è¡¡
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });

            // ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„API
            hands.onResults((results) => {
                onResults(results);
            });

            const videoElement = document.getElementById('video-input');
            
            // ä¿®å¤ï¼šä½¿ç”¨æ–°çš„Camera API
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: isMobile ? 320 : 640,  // è¿›ä¸€æ­¥é™ä½åˆ†è¾¨ç‡
                height: isMobile ? 240 : 480
            });

            statusEl.textContent = "è¯·æ±‚æ‘„åƒå¤´æƒé™...";
            
            try {
                await camera.start();
                statusEl.textContent = "ç³»ç»Ÿå°±ç»ª - è¯·å±•ç¤ºæ‰‹åŠ¿";
                statusEl.style.color = "#00ff00";
                statusEl.classList.remove('loading');
                setTimeout(() => { 
                    document.getElementById('ui-layer').style.opacity = '0.7'; 
                    statusEl.parentElement.style.display = 'none';
                }, 3000);
            } catch (camError) {
                console.error("æ‘„åƒå¤´é”™è¯¯:", camError);
                statusEl.textContent = "æ‘„åƒå¤´è®¿é—®å¤±è´¥";
                statusEl.style.color = "#ff0000";
                
                // æµ‹è¯•æ¨¡å¼ï¼šä½¿ç”¨é¼ æ ‡æ¨¡æ‹Ÿæ‰‹åŠ¿
                initMouseMode();
            }

        } catch (error) {
            console.error("MediaPipeé”™è¯¯:", error);
            statusEl.textContent = "AIæ¨¡å‹åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é¼ æ ‡æ¨¡å¼";
            statusEl.style.color = "#ff9900";
            
            // é™çº§åˆ°é¼ æ ‡æ¨¡å¼
            initMouseMode();
        }
    }

    // é¼ æ ‡æ¨¡æ‹Ÿæ¨¡å¼ï¼ˆå½“æ‘„åƒå¤´ä¸å¯ç”¨æ—¶ï¼‰
    function initMouseMode() {
        statusEl.textContent = "é¼ æ ‡æ¨¡å¼: ç§»åŠ¨é¼ æ ‡æ§åˆ¶ç²’å­";
        handLandmarks = {
            9: { x: 0.5, y: 0.5, z: 0 },
            0: { x: 0.5, y: 0.5, z: 0 }
        };
        
        document.addEventListener('mousemove', (e) => {
            if (handLandmarks) {
                handLandmarks[9].x = e.clientX / window.innerWidth;
                handLandmarks[9].y = e.clientY / window.innerHeight;
                handLandmarks[0].x = e.clientX / window.innerWidth;
                handLandmarks[0].y = e.clientY / window.innerHeight;
            }
        });
        
        // é”®ç›˜æ§åˆ¶å½¢çŠ¶åˆ‡æ¢
        document.addEventListener('keydown', (e) => {
            const shapes = ['sphere', 'torus', 'star', 'heart', 'text'];
            const shapeKeys = ['1', '2', '3', '4', '5'];
            const index = shapeKeys.indexOf(e.key);
            if (index !== -1 && shapeCache[shapes[index]]) {
                currentShape = shapes[index];
                targetPositions = shapeCache[shapes[index]];
                isExploding = true;
            }
        });
        
        // æ˜¾ç¤ºé”®ç›˜æç¤º
        const instruction = document.querySelector('.instruction');
        if (instruction) {
            instruction.innerHTML = "é”®ç›˜æ§åˆ¶: 1=çƒ 2=ç¯ 3=æ˜Ÿ 4=å¿ƒ 5=å­—<br>ç§»åŠ¨é¼ æ ‡æ¨¡æ‹Ÿæ‰‹åŠ¿";
        }
    }

    // --- 6. æ‰‹åŠ¿æ£€æµ‹é€»è¾‘ï¼ˆä¿®å¤ç‰ˆï¼‰---
    function detectGesture(lm) {
        // æ”¹è¿›çš„æ‰‹åŠ¿åˆ¤å®š
        const isFingerExtended = (tip, pip, mcp) => {
            // æ£€æŸ¥æŒ‡å°–æ˜¯å¦æ¯”æŒ‡å…³èŠ‚æ›´è¿œç¦»æ‰‹è…•
            const dTip = Math.sqrt(
                Math.pow(lm[tip].x - lm[0].x, 2) +
                Math.pow(lm[tip].y - lm[0].y, 2) +
                Math.pow(lm[tip].z - lm[0].z, 2)
            );
            const dPip = Math.sqrt(
                Math.pow(lm[pip].x - lm[0].x, 2) +
                Math.pow(lm[pip].y - lm[0].y, 2) +
                Math.pow(lm[pip].z - lm[0].z, 2)
            );
            return dTip > dPip * 1.15; // å¢åŠ å®¹å·®
        };

        // å„æ‰‹æŒ‡çŠ¶æ€
        const thumbUp = lm[4].y < lm[3].y; // æ‹‡æŒ‡å‘ä¸Šï¼ˆYè½´å‘ä¸‹ï¼‰
        const indexUp = isFingerExtended(8, 6, 5);
        const middleUp = isFingerExtended(12, 10, 9);
        const ringUp = isFingerExtended(16, 14, 13);
        const pinkyUp = isFingerExtended(20, 18, 17);

        const fingerStates = [indexUp, middleUp, ringUp, pinkyUp];
        const extendedCount = fingerStates.filter(Boolean).length;

        let newShape = 'sphere';
        
        // æ‰‹åŠ¿åˆ¤å®šé€»è¾‘
        if (extendedCount === 0) {
            // æ²¡æœ‰æ‰‹æŒ‡ä¼¸ç›´
            if (thumbUp) {
                newShape = 'heart'; // åªæœ‰æ‹‡æŒ‡ç«–èµ· = å¿ƒ
            } else {
                newShape = 'torus'; // æ¡æ‹³ = ç¯
            }
        } else if (extendedCount === 1) {
            // åªæœ‰ä¸€æ ¹æ‰‹æŒ‡ä¼¸ç›´
            if (indexUp && !middleUp && !ringUp && !pinkyUp) {
                newShape = 'star'; // é£ŸæŒ‡ = æ˜Ÿ
            } else if (thumbUp && !indexUp && !middleUp && !ringUp && !pinkyUp) {
                newShape = 'heart'; // åªæœ‰æ‹‡æŒ‡ = å¿ƒ
            }
        } else if (extendedCount === 2) {
            // ä¸¤æ ¹æ‰‹æŒ‡ä¼¸ç›´
            if (indexUp && middleUp && !ringUp && !pinkyUp) {
                newShape = 'text'; // å‰ªåˆ€æ‰‹ = å­—
            }
        } else if (extendedCount === 4) {
            // å››æŒ‡ä¼¸ç›´ = çƒ
            newShape = 'sphere';
        }

        // å¦‚æœæ£€æµ‹åˆ°æ–°æ‰‹åŠ¿ï¼Œåˆ‡æ¢å½¢çŠ¶
        if (newShape !== currentShape && shapeCache[newShape]) {
            currentShape = newShape;
            targetPositions = shapeCache[newShape];
            isExploding = true;
        }
    }

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handLandmarks = results.multiHandLandmarks[0];
            
            // è®¡ç®—æ‰‹é€Ÿ
            const wrist = handLandmarks[0];
            const currentVec = new THREE.Vector3(wrist.x, wrist.y, wrist.z);
            const speed = currentVec.distanceTo(lastHandPos) / 0.05; // dt approx
            handSpeed = handSpeed * 0.7 + speed * 0.3;
            lastHandPos.copy(currentVec);

            // æ·±åº¦ç¼©æ”¾
            const dist = Math.hypot(handLandmarks[0].x - handLandmarks[9].x, handLandmarks[0].y - handLandmarks[9].y);
            // ç§»åŠ¨ç«¯ç”±äºå±å¹•å°ï¼Œç¼©æ”¾å› å­è°ƒæ•´
            const sensitivity = isMobile ? 5 : 3;
            const targetScale = 0.6 + dist * sensitivity; 
            handSizeFactor = handSizeFactor * 0.9 + targetScale * 0.1;

            detectGesture(handLandmarks);
        } else {
            handLandmarks = null;
            handSpeed = 0;
            handSizeFactor = handSizeFactor * 0.95 + 1.0 * 0.05;
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- å¯åŠ¨åº”ç”¨ ---
    initThree();
    animate();

</script>
</body>
</html>
