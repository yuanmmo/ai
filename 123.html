<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR Fluid Particles - å…ƒé»˜</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: 0; }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10; color: #00ffff;
            text-shadow: 0 0 10px #00ffff; pointer-events: none;
        }
        .loading { font-size: 24px; animation: pulse 1s infinite; }
        .instruction { font-size: 14px; margin-top: 10px; opacity: 0.8; line-height: 1.6; }
        @keyframes pulse { 0% { opacity: 0.5; } 100% { opacity: 1; } }
        /* éšè— MediaPipe çš„ Canvasï¼Œæˆ‘ä»¬åªç”¨æ•°æ® */
        .output_canvas { display: none; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="status" class="loading">æ­£åœ¨åˆå§‹åŒ–ç¥ç»ç½‘ç»œ...</div>
    <div id="debug" class="instruction"></div>
    <div class="instruction">
        ğŸ– å¼ æ‰‹: çƒä½“ | âœŒï¸ å‰ªåˆ€: "æˆ‘æ˜¯ å…ƒé»˜" <br>
        âœŠ æ¡æ‹³: åœ†ç¯ | â˜ï¸ é£ŸæŒ‡: æ˜Ÿæ˜Ÿ <br>
        ğŸ‘ æ‹‡æŒ‡: çˆ±å¿ƒ | ğŸ‘‹ å¿«é€ŸæŒ¥æ‰‹: é£æš´
    </div>
</div>

<video id="video-input" playsinline></video>
<div id="canvas-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "@mediapipe/hands": "https://unpkg.com/@mediapipe/hands@0.4.1675469240/hands.js",
            "@mediapipe/camera_utils": "https://unpkg.com/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';

    // --- é…ç½®å‚æ•° ---
    const CONFIG = {
        particleCount: 16000,
        color: 0x00ffff,
        particleSize: 0.15,
        springStrength: 0.05,  // å½’ä½å¼¹åŠ›
        friction: 0.92,        // é˜»åŠ› (0-1)
        explosionForce: 0.5,   // åˆ‡æ¢å½¢æ€æ—¶çš„çˆ†ç‚¸åŠ›
        stormThreshold: 30,    // è§¦å‘é£æš´çš„æ‰‹é€Ÿé˜ˆå€¼
        stormForce: 2.0,       // é£æš´å¹æ•£åŠ›åº¦
        baseDepth: 20          // ç›¸æœºåŸºç¡€Zè·ç¦»
    };

    // --- å…¨å±€å˜é‡ ---
    let scene, camera, renderer, particlesMesh;
    let targetPositions = []; // ç›®æ ‡ä½ç½®æ•°ç»„
    let currentPositions, velocities; // ç‰©ç†å±æ€§
    let shapeCache = {}; // ç¼“å­˜å„å½¢æ€ç‚¹ä½
    let currentShape = 'sphere';
    let handLandmarks = null;
    let handSpeed = 0;
    let lastHandPos = new THREE.Vector3();
    let isExploding = false;
    let handSizeFactor = 1; // æ·±åº¦ç¼©æ”¾å› å­

    const container = document.getElementById('canvas-container');
    const statusEl = document.getElementById('status');
    const debugEl = document.getElementById('debug');

    // --- 1. Three.js åˆå§‹åŒ– ---
    function initThree() {
        scene = new THREE.Scene();
        // ç¨å¾®åŠ ä¸€ç‚¹é›¾è¥é€ æ·±é‚ƒæ„Ÿ
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.baseDepth;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        createParticles();
        
        // é¢„è®¡ç®—æ‰€æœ‰å½¢çŠ¶
        precomputeShapes();

        // ç›‘å¬è°ƒæ•´å¤§å°
        window.addEventListener('resize', onWindowResize);
    }

    // --- 2. ç²’å­ç³»ç»Ÿæ ¸å¿ƒ ---
    function createParticles() {
        const geometry = new THREE.BufferGeometry();
        currentPositions = new Float32Array(CONFIG.particleCount * 3);
        velocities = new Float32Array(CONFIG.particleCount * 3);
        
        // åˆå§‹éšæœºåˆ†å¸ƒ
        for (let i = 0; i < CONFIG.particleCount * 3; i++) {
            currentPositions[i] = (Math.random() - 0.5) * 50;
            velocities[i] = 0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

        // ç”Ÿæˆåœ†å½¢çº¹ç†ç”¨äºç²’å­
        const sprite = generateSprite();

        const material = new THREE.PointsMaterial({
            color: CONFIG.color,
            size: CONFIG.particleSize,
            map: sprite,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        particlesMesh = new THREE.Points(geometry, material);
        scene.add(particlesMesh);
    }

    function generateSprite() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.4, 'rgba(0,255,255,0.5)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        context.fillStyle = gradient;
        context.fillRect(0,0,32,32);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    // --- 3. å½¢çŠ¶ç”Ÿæˆç®—æ³• ---
    function precomputeShapes() {
        // 1. çƒä½“
        shapeCache.sphere = getSpherePoints(CONFIG.particleCount, 8);
        
        // 2. åœ†ç¯
        shapeCache.torus = getTorusPoints(CONFIG.particleCount, 7, 2.5);
        
        // 3. æ˜Ÿæ˜Ÿ
        shapeCache.star = getStarPoints(CONFIG.particleCount, 8, 3);

        // 4. çˆ±å¿ƒ
        shapeCache.heart = getHeartPoints(CONFIG.particleCount, 0.5);

        // 5. æ–‡å­— "æˆ‘æ˜¯ å…ƒé»˜"
        shapeCache.text = getTextPoints("æˆ‘æ˜¯\nå…ƒé»˜", CONFIG.particleCount);

        // åˆå§‹ç›®æ ‡
        targetPositions = shapeCache.sphere;
    }

    // è¾…åŠ©ï¼šçƒä½“æ•°å­¦æ¨¡å‹
    function getSpherePoints(count, radius) {
        const arr = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            const phi = Math.acos(-1 + (2 * i) / count);
            const theta = Math.sqrt(count * Math.PI) * phi;
            arr[i*3] = radius * Math.cos(theta) * Math.sin(phi);
            arr[i*3+1] = radius * Math.sin(theta) * Math.sin(phi);
            arr[i*3+2] = radius * Math.cos(phi);
        }
        return arr;
    }

    // è¾…åŠ©ï¼šåœ†ç¯æ•°å­¦æ¨¡å‹
    function getTorusPoints(count, R, r) {
        const arr = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI * 2;
            arr[i*3] = (R + r * Math.cos(v)) * Math.cos(u);
            arr[i*3+1] = (R + r * Math.cos(v)) * Math.sin(u);
            arr[i*3+2] = r * Math.sin(v);
        }
        return arr;
    }

    // è¾…åŠ©ï¼š3Dçˆ±å¿ƒå…¬å¼
    function getHeartPoints(count, scale) {
        const arr = new Float32Array(count * 3);
        let i = 0;
        while (i < count) {
            let x = (Math.random() - 0.5) * 40;
            let y = (Math.random() - 0.5) * 40;
            let z = (Math.random() - 0.5) * 40;
            // å¿ƒå½¢éšå‡½æ•°è¿‘ä¼¼
            let a = x*x + 2.25*y*y + z*z - 1;
            if (a*a*a - x*x*z*z*z - 0.1125*y*y*z*z*z <= 0) {
                // ç¼©æ”¾å¹¶æ—‹è½¬ä»¥æ­£å¯¹ç›¸æœº
                arr[i*3] = x * 4 * scale; 
                arr[i*3+1] = z * 4 * scale + 2; // äº¤æ¢y/zè½´è°ƒæ•´æœå‘
                arr[i*3+2] = -y * 2 * scale;
                i++;
            }
        }
        return arr;
    }

    // è¾…åŠ©ï¼šæ˜Ÿæ˜Ÿ (åŒå±‚äº”è§’æ˜Ÿ)
    function getStarPoints(count, outerR, innerR) {
        const arr = new Float32Array(count * 3);
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            // ç®€å•çš„å‚æ•°åŒ–æ˜Ÿæ˜Ÿï¼Œæˆ–è€…åœ¨åœ†ä¸Šé‡‡æ ·æŒ¤å‹
            // è¿™é‡Œç”¨ç®€å•çš„ 5 è§’æ˜Ÿé€»è¾‘ï¼šè§’åº¦ mod (2PI/5)
            const segment = Math.PI * 2 / 5;
            const a = (Math.atan2(Math.sin(angle), Math.cos(angle)) + Math.PI) % segment;
            const r = (a < segment/2) ? 
                      outerR : innerR + (outerR-innerR)*Math.random(); // ç®€åŒ–ç‰ˆå¡«å……
            
            // ä¸ºäº†ç¾è§‚ï¼Œæˆ‘ä»¬ç”¨å‡ ä½•ç”Ÿæˆæ³•ï¼š5ä¸ªç‚¹è¿çº¿
            // è¿™é‡Œæ”¹ç”¨ä¸€ä¸ªæ›´ç®€å•çš„ 2D Extrude é€»è¾‘
            const k = 5;
            const t = Math.random() * Math.PI * 2;
            // æåæ ‡ç«ç‘°çº¿æ¨¡æ‹Ÿæ˜Ÿæ˜Ÿ
            const starR = outerR * (Math.cos(k * t) + 2) / 3;
            
            arr[i*3] = starR * Math.cos(t) * 2;
            arr[i*3+1] = starR * Math.sin(t) * 2;
            arr[i*3+2] = (Math.random() - 0.5) * 2; // åšåº¦
        }
        return arr;
    }

    // è¾…åŠ©ï¼šCanvasæ–‡å­—è½¬ç‚¹äº‘
    function getTextPoints(text, count) {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000000';
        ctx.fillRect(0,0,1024,1024);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 200px "Microsoft YaHei", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const lines = text.split('\n');
        lines.forEach((line, idx) => {
            ctx.fillText(line, 512, 400 + idx * 220);
        });

        const imageData = ctx.getImageData(0, 0, 1024, 1024);
        const data = imageData.data;
        const validPixels = [];

        // é‡‡æ ·åƒç´  (æ­¥é•¿4ä»¥æé«˜æ€§èƒ½)
        for(let y=0; y<1024; y+=4) {
            for(let x=0; x<1024; x+=4) {
                if(data[(y*1024+x)*4] > 128) {
                    validPixels.push({x: (x-512)/30, y: -(y-512)/30});
                }
            }
        }

        const arr = new Float32Array(count * 3);
        for(let i=0; i<count; i++) {
            // å¦‚æœåƒç´ ç‚¹ä¸å¤Ÿï¼Œéšæœºå–ï¼›å¤Ÿåˆ™æŒ‰é¡ºåºå–
            const p = validPixels[i % validPixels.length] || {x:0, y:0};
            // æ·»åŠ ä¸€ç‚¹æŠ–åŠ¨é˜²æ­¢æ‘©å°”çº¹
            arr[i*3] = p.x + (Math.random()-0.5)*0.2;
            arr[i*3+1] = p.y + (Math.random()-0.5)*0.2;
            arr[i*3+2] = (Math.random()-0.5) * 1; // 3Dåšåº¦
        }
        return arr;
    }

    // --- 4. ç‰©ç†å¾ªç¯ (Animation Loop) ---
    function animate() {
        requestAnimationFrame(animate);

        // è·å–ä½ç½®å±æ€§
        const positions = particlesMesh.geometry.attributes.position.array;

        // æ‰‹éƒ¨äº¤äº’è®¡ç®—
        let handX = 9999, handY = 9999, handZ = 0;
        let isStorming = false;

        if (handLandmarks) {
            // æ˜ å°„ MediaPipe (0-1) åˆ° Three.js åæ ‡ç³»
            // å±å¹•ä¸­å¿ƒ (0,0), å®½åº¦çº¦ 30-40 å•ä½
            const aspect = window.innerWidth / window.innerHeight;
            // æŒå¿ƒå¤§æ¦‚åœ¨ 0 (Wrist) å’Œ 9 (Middle MCP) ä¹‹é—´
            const palm = handLandmarks[9]; 
            handX = (0.5 - palm.x) * 30 * aspect; // Xè½´åè½¬
            handY = (0.5 - palm.y) * 30;
            
            // é£æš´é€»è¾‘
            if (handSpeed > CONFIG.stormThreshold) {
                isStorming = true;
            }
        }

        // ç²’å­ç‰©ç†æ›´æ–°
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const idx = i * 3;
            
            // 1. è·å–å½“å‰çŠ¶æ€
            let px = positions[idx];
            let py = positions[idx+1];
            let pz = positions[idx+2];

            let vx = velocities[idx];
            let vy = velocities[idx+1];
            let vz = velocities[idx+2];

            // 2. ç›®æ ‡å¸å¼•åŠ› (Hooke's Law)
            // æ ¹æ®æ·±åº¦ç¼©æ”¾ç›®æ ‡ä½ç½®
            let tx = targetPositions[idx] * handSizeFactor;
            let ty = targetPositions[idx+1] * handSizeFactor;
            let tz = targetPositions[idx+2] * handSizeFactor;

            let ax = (tx - px) * CONFIG.springStrength;
            let ay = (ty - py) * CONFIG.springStrength;
            let az = (tz - pz) * CONFIG.springStrength;

            // 3. äº¤äº’åŠ›ï¼šé£æš´ (Repulsion)
            if (isStorming) {
                const dx = px - handX;
                const dy = py - handY;
                // ç®€å•çš„è·ç¦»å¹³æ–¹æ’æ–¥
                const distSq = dx*dx + dy*dy;
                if (distSq < 100) { // å½±å“åŠå¾„
                    const force = CONFIG.stormForce / (distSq + 0.1);
                    ax += dx * force * 2;
                    ay += dy * force * 2;
                    az += (Math.random()-0.5) * force * 5; // å¢åŠ Zè½´æ··ä¹±
                }
            }

            // 4. äº¤äº’åŠ›ï¼šçˆ†ç‚¸è¿‡æ¸¡
            if (isExploding) {
                // ç¬é—´ç»™äºˆéšæœºå‘å¤–é€Ÿåº¦
                vx += (Math.random() - 0.5) * CONFIG.explosionForce * 10;
                vy += (Math.random() - 0.5) * CONFIG.explosionForce * 10;
                vz += (Math.random() - 0.5) * CONFIG.explosionForce * 10;
            }

            // 5. ç§¯åˆ†æ›´æ–°
            vx += ax;
            vy += ay;
            vz += az;

            vx *= CONFIG.friction;
            vy *= CONFIG.friction;
            vz *= CONFIG.friction;

            positions[idx]   += vx;
            positions[idx+1] += vy;
            positions[idx+2] += vz;

            velocities[idx]   = vx;
            velocities[idx+1] = vy;
            velocities[idx+2] = vz;
        }

        // é‡ç½®çˆ†ç‚¸æ ‡è®°ï¼ˆåªä½œç”¨ä¸€å¸§ï¼Œæˆ–è€…é€šè¿‡è¡°å‡æ§åˆ¶ï¼Œè¿™é‡Œç®€å•å¤„ç†ä¸ºå•å¸§è„‰å†²åç”±ç‰©ç†æ¥ç®¡ï¼‰
        if(isExploding) isExploding = false;

        // æ›´æ–°å‡ ä½•ä½“
        particlesMesh.geometry.attributes.position.needsUpdate = true;
        
        // ç¼“æ…¢æ—‹è½¬æ•´ä¸ªç³»ç»Ÿå¢åŠ åŠ¨æ„Ÿ
        particlesMesh.rotation.y += 0.001;
        particlesMesh.rotation.z += 0.0005;

        renderer.render(scene, camera);
    }

    // --- 5. MediaPipe Hands é›†æˆ ---
    function initMediaPipe() {
        // åŠ¨æ€åŠ è½½ global è„šæœ¬
        const script1 = document.createElement('script');
        script1.src = "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js";
        script1.onload = () => {
            const script2 = document.createElement('script');
            script2.src = "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";
            script2.onload = startHands;
            document.body.appendChild(script2);
        };
        document.body.appendChild(script1);
    }

    // ç”±äº unpkg çš„ module å¯¼å…¥åœ¨ web worker æˆ–æŸäº›ç¯å¢ƒä¸‹å¯èƒ½å¤æ‚ï¼Œ
    // è¿™é‡Œæˆ‘ä»¬å‡è®¾ html script æ ‡ç­¾å·²ç»å¼•å…¥äº†å…¨å±€å˜é‡ `window.Hands` å’Œ `window.Camera`
    // æˆ–è€…ä½¿ç”¨ä¸Šæ–¹ importmapã€‚ä¸ºç¡®ä¿ç¨³å¥æ€§ï¼Œè¿™é‡Œä½¿ç”¨ window å…¨å±€å¯¹è±¡çš„ä¼ ç»Ÿæ–¹å¼ã€‚
    
    function startHands() {
        const videoElement = document.getElementById('video-input');
        
        // æ³¨æ„ï¼šUnpkg å¼•å…¥çš„ global å˜é‡é€šå¸¸æ˜¯ window.Hands
        // ä½†ç”±äºæˆ‘ä»¬ä½¿ç”¨äº† type=module å’Œ importmapï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ç”¨ Hands ç±»
        // å¦‚æœ importmap å¤±è´¥ï¼Œå›é€€é€»è¾‘éœ€è¦å¤„ç†ã€‚ä¸ºç®€åŒ–ï¼Œè¿™é‡Œå‡å®š importmap æœ‰æ•ˆã€‚
        // ä½† MediaPipe å®˜æ–¹ JS åŒ…åœ¨æµè§ˆå™¨ç«¯è¡Œä¸ºæ¯”è¾ƒç‰¹æ®Šï¼Œé€šå¸¸æŒ‚è½½åœ¨ window ä¸Šã€‚
        
        const hands = new window.Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraFeed = new window.Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraFeed.start()
            .then(() => {
                statusEl.textContent = "ç³»ç»Ÿå°±ç»ª - è¯·å±•ç¤ºæ‰‹åŠ¿";
                statusEl.style.color = "#00ff00";
                setTimeout(() => { statusEl.style.display = 'none'; }, 2000);
            })
            .catch(err => {
                statusEl.textContent = "æ‘„åƒå¤´è®¿é—®å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™";
                console.error(err);
            });
    }

    // --- 6. æ‰‹åŠ¿è¯†åˆ«ä¸é€»è¾‘ ---
    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handLandmarks = results.multiHandLandmarks[0];
            
            // 1. è®¡ç®—æ‰‹é€Ÿ (ç”¨äºé£æš´)
            const wrist = handLandmarks[0];
            const currentVec = new THREE.Vector3(wrist.x, wrist.y, wrist.z);
            // è·ç¦» / æ—¶é—´ (å‡è®¾çº¦30fps, dt ~ 0.033)
            const speed = currentVec.distanceTo(lastHandPos) / 0.03; 
            // å¹³æ»‘å¤„ç†
            handSpeed = handSpeed * 0.8 + speed * 0.2;
            lastHandPos.copy(currentVec);

            // 2. è®¡ç®—æ·±åº¦ç¼©æ”¾ (åŸºäºæ‰‹æŒè¾¹ç•Œæ¡†é¢ç§¯)
            // ç®€å•ä¼°ç®—ï¼šæ‰‹è…•åˆ°ä¸­æŒ‡æ ¹éƒ¨çš„è·ç¦»
            const dist = Math.hypot(handLandmarks[0].x - handLandmarks[9].x, handLandmarks[0].y - handLandmarks[9].y);
            // æ˜ å°„ï¼šè·ç¦»è¶Šå¤§(æ‰‹è¶Šè¿‘)ï¼Œç‰©ä½“è¶Šå¤§
            const targetScale = 0.5 + dist * 3; 
            handSizeFactor = handSizeFactor * 0.9 + targetScale * 0.1;

            // 3. è¯†åˆ«æ‰‹åŠ¿
            detectGesture(handLandmarks);

            debugEl.innerText = `Gesture: ${currentShape.toUpperCase()} | Speed: ${handSpeed.toFixed(1)}`;
        } else {
            handLandmarks = null;
            handSpeed = 0;
            // æ‰‹æ¶ˆå¤±æ—¶ï¼Œæ…¢æ…¢æ¢å¤é»˜è®¤å¤§å°å’Œå½¢çŠ¶
            handSizeFactor = handSizeFactor * 0.95 + 1.0 * 0.05;
        }
    }

    function detectGesture(lm) {
        // ç®€å•çŠ¶æ€æœºï¼šæ£€æµ‹æ‰‹æŒ‡ä¼¸ç›´/å¼¯æ›²
        // 0:Wrist, 4:ThumbTip, 8:IndexTip, 12:MidTip, 16:RingTip, 20:PinkyTip
        // ç®€å•åˆ¤å®šï¼šæŒ‡å°–ä½ç½®æ˜¯å¦ä½äºæŒ‡å…³èŠ‚ (å¯¹äºä¸Šä¸¾çš„æ‰‹) - ä½†è¿™å—æ–¹å‘å½±å“ã€‚
        // é²æ£’åˆ¤å®šï¼šæŒ‡å°–åˆ°æ‰‹è…•è·ç¦» > æŒ‡å…³èŠ‚åˆ°æ‰‹è…•è·ç¦»
        
        const isFingerUp = (tipIdx, pipIdx) => {
            const dTip = Math.hypot(lm[tipIdx].x - lm[0].x, lm[tipIdx].y - lm[0].y);
            const dPip = Math.hypot(lm[pipIdx].x - lm[0].x, lm[pipIdx].y - lm[0].y);
            return dTip > dPip; // ä¼¸ç›´
        };

        const thumbUp = isFingerUp(4, 2); // æ‹‡æŒ‡æ¯”è¾ƒç‰¹æ®Šçš„å…³èŠ‚
        const indexUp = isFingerUp(8, 6);
        const midUp = isFingerUp(12, 10);
        const ringUp = isFingerUp(16, 14);
        const pinkyUp = isFingerUp(20, 18);

        let detected = 'sphere';

        // é€»è¾‘åˆ¤æ–­æ ‘
        if (!indexUp && !midUp && !ringUp && !pinkyUp) {
             // å››æŒ‡å·æ›²
             if (thumbUp) detected = 'heart'; // ğŸ‘ æ‹‡æŒ‡
             else detected = 'torus';         // âœŠ æ¡æ‹³
        } else if (indexUp && midUp && !ringUp && !pinkyUp) {
            detected = 'text'; // âœŒï¸ å‰ªåˆ€æ‰‹
        } else if (indexUp && !midUp && !ringUp && !pinkyUp) {
            detected = 'star'; // â˜ï¸ é£ŸæŒ‡
        } else if (indexUp && midUp && ringUp && pinkyUp) {
            detected = 'sphere'; // ğŸ– å¼ æ‰‹
        }

        // çŠ¶æ€åˆ‡æ¢å¤„ç†
        if (detected !== currentShape) {
            currentShape = detected;
            changeShape(detected);
        }
    }

    function changeShape(shapeName) {
        if (shapeCache[shapeName]) {
            targetPositions = shapeCache[shapeName];
            isExploding = true; // è§¦å‘çˆ†ç‚¸ç‰¹æ•ˆ
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- å¯åŠ¨ ---
    initThree();
    // ç”±äº importmap åŠ è½½ mediapipe å¯èƒ½å­˜åœ¨è·¯å¾„é—®é¢˜ï¼Œæˆ‘ä»¬ä½¿ç”¨å…¨å±€æŒ‚è½½çš„å›è°ƒæ–¹å¼ç¡®ä¿åŠ è½½
    if (window.Hands) {
        startHands();
    } else {
        // å¦‚æœæ¨¡å—æœªåŠ è½½å®Œæˆï¼Œç­‰å¾… loading
        const checkInterval = setInterval(() => {
            if (window.Hands) {
                clearInterval(checkInterval);
                startHands();
            }
        }, 500);
    }
    animate();

</script>
</body>
</html>
