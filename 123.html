<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>手势粒子互动系统 | WebAR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a1a;
            color: #e0f7fa;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        #arCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: block;
        }
        
        #infoPanel {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 20, 40, 0.85);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            max-width: 300px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 200, 255, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        #infoPanel h1 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #4fc3f7;
            text-align: center;
        }
        
        #gestureStatus {
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 30, 60, 0.7);
            border-radius: 6px;
            font-size: 14px;
            border-left: 3px solid #4fc3f7;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.85);
            padding: 12px 20px;
            border-radius: 10px;
            z-index: 100;
            text-align: center;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 200, 255, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            max-width: 90%;
        }
        
        #instructions p {
            margin: 5px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .highlight {
            color: #4fc3f7;
            font-weight: bold;
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(79, 195, 247, 0.2);
            border-top: 5px solid #4fc3f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #loading h2 {
            color: #4fc3f7;
            margin-bottom: 15px;
        }
        
        #loading p {
            color: #b0e0f0;
            text-align: center;
            max-width: 80%;
            line-height: 1.5;
        }
        
        .stats {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 20, 40, 0.85);
            padding: 10px;
            border-radius: 8px;
            z-index: 100;
            font-size: 12px;
            border: 1px solid rgba(0, 200, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .hidden {
            display: none !important;
        }
        
        .fade-out {
            opacity: 0;
        }
        
        @media (max-width: 768px) {
            #infoPanel, .stats {
                padding: 10px;
                font-size: 12px;
            }
            
            #infoPanel h1 {
                font-size: 18px;
            }
            
            #instructions {
                padding: 10px 15px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="arCanvas"></canvas>
        <div id="infoPanel">
            <h1>手势粒子互动系统</h1>
            <div>粒子数量: <span id="particleCount">16,000</span></div>
            <div>手势状态: <span id="gestureStatus">检测中...</span></div>
            <div>手部距离: <span id="handDistance">--</span></div>
        </div>
        <div class="stats">
            <div>FPS: <span id="fpsCounter">0</span></div>
            <div>手速: <span id="handSpeed">0</span></div>
        </div>
        <div id="instructions">
            <p><span class="highlight">手势控制:</span> 张开手(球) | 剪刀手(文字) | 握拳(圆环) | 食指(星) | 竖拇指(心)</p>
            <p><span class="highlight">交互:</span> 快速挥手产生风暴 | 手掌靠近/远离控制大小</p>
        </div>
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <h2>加载手势识别与粒子系统</h2>
        <p>正在初始化 MediaPipe Hands 和 Three.js 粒子引擎...</p>
        <p>请确保摄像头权限已开启</p>
    </div>

    <script type="module">
        // 从 unpkg 导入所需库
        import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.157.0/examples/jsm/controls/OrbitControls.js';
        
        // 全局变量
        let scene, camera, renderer, controls;
        let particles, particleGeometry, particleMaterial;
        let particlePositions, particleVelocities, particleAccelerations;
        let handMesh, handSkeleton;
        let handDetected = false;
        let currentGesture = 'none';
        let targetShape = 'sphere';
        let lastGestureChange = 0;
        let explosionTime = 0;
        let lastHandPosition = null;
        let handSpeed = 0;
        let handSize = 0;
        let windForce = new THREE.Vector3(0, 0, 0);
        let gestureStartTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let fps = 0;
        
        // 粒子系统常量
        const PARTICLE_COUNT = 16000;
        const PARTICLE_COLOR = 0x00ffff; // 青色
        const SHAPE_CHANGE_SPEED = 0.05;
        const EXPLOSION_DURATION = 0.8;
        const WIND_DECAY = 0.95;
        const PHYSICS_DAMPING = 0.98;
        const ATTRACTION_FORCE = 0.1;
        const REPULSION_FORCE = 0.5;
        
        // 初始化 Three.js 场景
        function initThreeJS() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 50);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('arCanvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // 添加轨道控制（调试用）
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enabled = false; // 默认禁用，手势控制时启用
            
            // 初始化粒子系统
            initParticles();
            
            // 添加简单手部模型用于可视化
            initHandModel();
            
            // 窗口大小调整事件
            window.addEventListener('resize', onWindowResize);
        }
        
        // 初始化粒子系统
        function initParticles() {
            // 创建粒子几何体
            particleGeometry = new THREE.BufferGeometry();
            
            // 初始化位置、速度和加速度数组
            particlePositions = new Float32Array(PARTICLE_COUNT * 3);
            particleVelocities = new Float32Array(PARTICLE_COUNT * 3);
            particleAccelerations = new Float32Array(PARTICLE_COUNT * 3);
            
            // 随机初始化粒子位置和速度
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 随机位置（球体内）
                const radius = 15;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = radius * Math.cbrt(Math.random());
                
                particlePositions[i3] = r * Math.sin(phi) * Math.cos(theta);
                particlePositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                particlePositions[i3 + 2] = r * Math.cos(phi);
                
                // 初始速度为零
                particleVelocities[i3] = 0;
                particleVelocities[i3 + 1] = 0;
                particleVelocities[i3 + 2] = 0;
                
                // 初始加速度为零
                particleAccelerations[i3] = 0;
                particleAccelerations[i3 + 1] = 0;
                particleAccelerations[i3 + 2] = 0;
            }
            
            // 设置几何体属性
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            // 创建粒子材质
            particleMaterial = new THREE.PointsMaterial({
                color: PARTICLE_COLOR,
                size: 0.1,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // 创建粒子系统
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }
        
        // 初始化手部模型（用于可视化）
        function initHandModel() {
            const handGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const handMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff3366, 
                transparent: true, 
                opacity: 0.7 
            });
            
            handMesh = new THREE.Mesh(handGeometry, handMaterial);
            handMesh.visible = false;
            scene.add(handMesh);
            
            // 创建手部骨架（21个关节点）
            handSkeleton = [];
            for (let i = 0; i < 21; i++) {
                const jointGeometry = new THREE.SphereGeometry(0.2, 6, 6);
                const jointMaterial = new THREE.MeshBasicMaterial({ color: 0x4fc3f7 });
                const joint = new THREE.Mesh(jointGeometry, jointMaterial);
                joint.visible = false;
                scene.add(joint);
                handSkeleton.push(joint);
            }
        }
        
        // 窗口大小调整处理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 更新粒子物理
        function updateParticles(deltaTime) {
            const positions = particleGeometry.attributes.position.array;
            const now = Date.now() / 1000;
            const isExploding = (now - lastGestureChange) < EXPLOSION_DURATION;
            
            // 根据目标形状计算吸引力点
            let targetPoints = [];
            if (targetShape === 'sphere') {
                // 球体
                const radius = 10;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    targetPoints.push(new THREE.Vector3(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    ));
                }
            } else if (targetShape === 'text') {
                // 文字形状 - "我是 元默"
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    // 简单实现：随机分布在文字区域内
                    const x = (Math.random() - 0.5) * 25;
                    const y = (Math.random() - 0.5) * 10;
                    const z = (Math.random() - 0.5) * 5;
                    
                    // 简单的文字形状分布（实际应该使用文字轮廓）
                    let inText = false;
                    // "我" 字区域
                    if (x > -12 && x < -6 && y > -2 && y < 2) inText = true;
                    // "是" 字区域
                    if (x > -5 && x < 1 && y > -2 && y < 2) inText = true;
                    // "元" 字区域
                    if (x > 2 && x < 8 && y > -2 && y < 2) inText = true;
                    // "默" 字区域
                    if (x > 9 && x < 15 && y > -2 && y < 2) inText = true;
                    
                    if (inText) {
                        targetPoints.push(new THREE.Vector3(x, y, z));
                    } else {
                        // 如果在文字外，则向中心吸引
                        targetPoints.push(new THREE.Vector3(0, 0, 0));
                    }
                }
            } else if (targetShape === 'ring') {
                // 圆环
                const radius = 12;
                const thickness = 2;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = radius + (Math.random() - 0.5) * thickness;
                    targetPoints.push(new THREE.Vector3(
                        Math.cos(angle) * r,
                        Math.sin(angle) * r,
                        (Math.random() - 0.5) * thickness
                    ));
                }
            } else if (targetShape === 'star') {
                // 星形
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 8 + Math.sin(angle * 5) * 3;
                    targetPoints.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        (Math.random() - 0.5) * 4
                    ));
                }
            } else if (targetShape === 'heart') {
                // 心形
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const t = Math.random() * Math.PI * 2;
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    const z = (Math.random() - 0.5) * 5;
                    targetPoints.push(new THREE.Vector3(x * 0.5, y * 0.5 - 3, z));
                }
            }
            
            // 更新每个粒子的物理状态
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 获取当前位置
                const currentPosition = new THREE.Vector3(
                    positions[i3],
                    positions[i3 + 1],
                    positions[i3 + 2]
                );
                
                // 计算目标位置
                let targetPosition = targetPoints[i] || new THREE.Vector3(0, 0, 0);
                
                // 爆炸效果
                if (isExploding) {
                    const explosionProgress = (now - lastGestureChange) / EXPLOSION_DURATION;
                    const explosionIntensity = 1 - explosionProgress;
                    
                    // 添加随机爆炸力
                    const explosionForce = new THREE.Vector3(
                        (Math.random() - 0.5) * 50 * explosionIntensity,
                        (Math.random() - 0.5) * 50 * explosionIntensity,
                        (Math.random() - 0.5) * 50 * explosionIntensity
                    );
                    
                    particleAccelerations[i3] += explosionForce.x;
                    particleAccelerations[i3 + 1] += explosionForce.y;
                    particleAccelerations[i3 + 2] += explosionForce.z;
                }
                
                // 计算吸引力（指向目标形状）
                const attraction = new THREE.Vector3();
                attraction.subVectors(targetPosition, currentPosition);
                attraction.multiplyScalar(ATTRACTION_FORCE * (isExploding ? 0.1 : 1));
                
                // 添加吸引力到加速度
                particleAccelerations[i3] += attraction.x;
                particleAccelerations[i3 + 1] += attraction.y;
                particleAccelerations[i3 + 2] += attraction.z;
                
                // 添加风力
                particleAccelerations[i3] += windForce.x;
                particleAccelerations[i3 + 1] += windForce.y;
                particleAccelerations[i3 + 2] += windForce.z;
                
                // 手部排斥力（如果手被检测到）
                if (handDetected && handMesh.visible) {
                    const handPosition = handMesh.position;
                    const handToParticle = new THREE.Vector3();
                    handToParticle.subVectors(currentPosition, handPosition);
                    const distance = handToParticle.length();
                    
                    if (distance < 10) {
                        const repulsionStrength = REPULSION_FORCE * (1 - distance / 10) * handSize;
                        handToParticle.normalize().multiplyScalar(repulsionStrength);
                        
                        particleAccelerations[i3] += handToParticle.x;
                        particleAccelerations[i3 + 1] += handToParticle.y;
                        particleAccelerations[i3 + 2] += handToParticle.z;
                    }
                }
                
                // 更新速度：v = v + a * dt
                particleVelocities[i3] += particleAccelerations[i3] * deltaTime;
                particleVelocities[i3 + 1] += particleAccelerations[i3 + 1] * deltaTime;
                particleVelocities[i3 + 2] += particleAccelerations[i3 + 2] * deltaTime;
                
                // 应用阻尼
                particleVelocities[i3] *= PHYSICS_DAMPING;
                particleVelocities[i3 + 1] *= PHYSICS_DAMPING;
                particleVelocities[i3 + 2] *= PHYSICS_DAMPING;
                
                // 更新位置：p = p + v * dt
                positions[i3] += particleVelocities[i3] * deltaTime;
                positions[i3 + 1] += particleVelocities[i3 + 1] * deltaTime;
                positions[i3 + 2] += particleVelocities[i3 + 2] * deltaTime;
                
                // 重置加速度
                particleAccelerations[i3] = 0;
                particleAccelerations[i3 + 1] = 0;
                particleAccelerations[i3 + 2] = 0;
            }
            
            // 衰减风力
            windForce.multiplyScalar(WIND_DECAY);
            
            // 标记几何体需要更新
            particleGeometry.attributes.position.needsUpdate = true;
        }
        
        // 根据手势更新目标形状
        function updateGesture(newGesture) {
            if (newGesture !== currentGesture) {
                currentGesture = newGesture;
                lastGestureChange = Date.now() / 1000;
                
                // 根据手势设置目标形状
                switch(newGesture) {
                    case 'open':
                        targetShape = 'sphere';
                        document.getElementById('gestureStatus').textContent = '张开手 → 球体';
                        break;
                    case 'victory':
                        targetShape = 'text';
                        document.getElementById('gestureStatus').textContent = '剪刀手 → 文字';
                        break;
                    case 'fist':
                        targetShape = 'ring';
                        document.getElementById('gestureStatus').textContent = '握拳 → 圆环';
                        break;
                    case 'pointing':
                        targetShape = 'star';
                        document.getElementById('gestureStatus').textContent = '食指 → 星星';
                        break;
                    case 'thumbs_up':
                        targetShape = 'heart';
                        document.getElementById('gestureStatus').textContent = '竖拇指 → 爱心';
                        break;
                    default:
                        targetShape = 'sphere';
                        document.getElementById('gestureStatus').textContent = '检测中...';
                }
                
                // 触发爆炸效果
                explosionTime = EXPLOSION_DURATION;
            }
        }
        
        // 根据手部速度创建风力
        function applyWindFromHandMovement(handPosition) {
            const now = Date.now();
            
            if (lastHandPosition) {
                const deltaTime = (now - lastHandPosition.time) / 1000;
                if (deltaTime > 0) {
                    // 计算手部速度
                    const positionDelta = new THREE.Vector3();
                    positionDelta.subVectors(handPosition, lastHandPosition.pos);
                    
                    handSpeed = positionDelta.length() / deltaTime;
                    
                    // 如果手速足够快，创建风力
                    if (handSpeed > 20) {
                        const windStrength = Math.min((handSpeed - 20) / 50, 2.0);
                        windForce.add(positionDelta.normalize().multiplyScalar(windStrength * 5));
                        
                        // 更新显示
                        document.getElementById('handSpeed').textContent = handSpeed.toFixed(1);
                    }
                }
            }
            
            // 保存当前手部位置
            lastHandPosition = {
                pos: handPosition.clone(),
                time: now
            };
        }
        
        // 根据手部大小调整粒子系统缩放
        function updateParticleScaleByHandSize(size) {
            handSize = size;
            
            // 根据手部大小调整粒子大小
            const scaleFactor = 0.5 + size * 1.5;
            particles.scale.set(scaleFactor, scaleFactor, scaleFactor);
            
            // 更新显示
            document.getElementById('handDistance').textContent = size.toFixed(2);
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 计算增量时间（限制最大增量时间避免物理不稳定）
            const now = Date.now() / 1000;
            const deltaTime = Math.min(now - (lastFpsUpdate || now), 0.033); // 限制到30fps的最小时间步长
            
            // 更新粒子物理
            updateParticles(deltaTime);
            
            // 更新手部模型位置（如果可见）
            if (handMesh.visible) {
                handMesh.rotation.y += 0.01;
            }
            
            // 更新控件
            controls.update();
            
            // 渲染场景
            renderer.render(scene, camera);
            
            // 更新FPS计数
            updateFPS(now);
        }
        
        // 更新FPS显示
        function updateFPS(now) {
            frameCount++;
            
            if (now - lastFpsUpdate >= 0.5) {
                fps = Math.round(frameCount / (now - lastFpsUpdate));
                document.getElementById('fpsCounter').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }
        
        // 初始化 MediaPipe Hands
        async function initMediaPipe() {
            console.log('正在加载 MediaPipe Hands...');
            
            // 动态加载 MediaPipe
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
            script.crossOrigin = 'anonymous';
            
            script.onload = async () => {
                console.log('MediaPipe Hands 加载成功');
                
                // 创建 Hands 实例
                const hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                // 配置参数
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                // 设置结果回调
                hands.onResults(onHandResults);
                
                // 初始化摄像头
                const camera = new Camera(document.getElementById('arCanvas'), {
                    onFrame: async () => {
                        await hands.send({image: document.getElementById('arCanvas')});
                    },
                    width: 640,
                    height: 480
                });
                
                try {
                    await camera.start();
                    console.log('摄像头启动成功');
                    
                    // 隐藏加载界面
                    setTimeout(() => {
                        document.getElementById('loading').classList.add('fade-out');
                        setTimeout(() => {
                            document.getElementById('loading').classList.add('hidden');
                        }, 500);
                    }, 1000);
                    
                } catch (error) {
                    console.error('摄像头启动失败:', error);
                    document.getElementById('loading').innerHTML = 
                        '<h2>摄像头错误</h2><p>无法访问摄像头。请确保已授予摄像头权限并刷新页面。</p>';
                }
            };
            
            script.onerror = () => {
                console.error('MediaPipe Hands 加载失败');
                document.getElementById('loading').innerHTML = 
                    '<h2>加载失败</h2><p>无法加载 MediaPipe Hands。请检查网络连接并刷新页面。</p>';
            };
            
            document.head.appendChild(script);
        }
        
        // MediaPipe Hands 结果处理
        function onHandResults(results) {
            // 更新手部检测状态
            handDetected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;
            
            if (handDetected) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 显示手部模型
                handMesh.visible = true;
                
                // 将手部坐标转换为 Three.js 坐标
                // MediaPipe 的坐标范围是 [0,1]，需要转换为 Three.js 坐标
                const x = (landmarks[0].x - 0.5) * 40;
                const y = (0.5 - landmarks[0].y) * 30;
                const z = landmarks[0].z * 20;
                
                handMesh.position.set(x, y, z);
                
                // 更新手部关节点
                for (let i = 0; i < Math.min(landmarks.length, 21); i++) {
                    const joint = handSkeleton[i];
                    if (joint) {
                        joint.position.set(
                            (landmarks[i].x - 0.5) * 40,
                            (0.5 - landmarks[i].y) * 30,
                            landmarks[i].z * 20
                        );
                        joint.visible = true;
                    }
                }
                
                // 应用手部运动风力
                applyWindFromHandMovement(handMesh.position);
                
                // 计算手部大小（根据手腕和手指的距离）
                const wrist = landmarks[0];
                const middleFingerTip = landmarks[12];
                const handWidth = Math.sqrt(
                    Math.pow(wrist.x - middleFingerTip.x, 2) + 
                    Math.pow(wrist.y - middleFingerTip.y, 2)
                );
                
                // 根据手部大小调整粒子系统缩放
                updateParticleScaleByHandSize(handWidth);
                
                // 手势识别逻辑
                const fingersUp = countFingersUp(landmarks);
                
                // 根据手指状态判断手势
                if (fingersUp === 5) {
                    updateGesture('open'); // 张开手
                } else if (fingersUp === 2 && 
                          isFingerUp(landmarks, 7) && // 食指
                          isFingerUp(landmarks, 11)) { // 中指
                    updateGesture('victory'); // 剪刀手
                } else if (fingersUp === 0) {
                    updateGesture('fist'); // 握拳
                } else if (fingersUp === 1 && isFingerUp(landmarks, 7)) {
                    updateGesture('pointing'); // 食指
                } else if (fingersUp === 1 && isFingerUp(landmarks, 4)) {
                    updateGesture('thumbs_up'); // 竖拇指
                }
                
            } else {
                // 没有检测到手部，隐藏模型
                handMesh.visible = false;
                handSkeleton.forEach(joint => joint.visible = false);
                document.getElementById('gestureStatus').textContent = '未检测到手部';
            }
        }
        
        // 计算手指是否竖起
        function isFingerUp(landmarks, tipIndex) {
            // 简化版手指检测逻辑
            // 实际应该检查手指关节点之间的角度
            const tip = landmarks[tipIndex];
            const pip = landmarks[tipIndex - 2]; // 近端指间关节
            
            // 如果指尖比近端指间关节高（Y坐标更小），则认为手指竖起
            return tip.y < pip.y;
        }
        
        // 计算竖起的手指数量
        function countFingersUp(landmarks) {
            let count = 0;
            
            // 拇指 (4)
            const thumbTip = landmarks[4];
            const thumbIp = landmarks[3];
            if (thumbTip.x < thumbIp.x) count++; // 拇指特殊处理
            
            // 食指 (8)
            if (isFingerUp(landmarks, 8)) count++;
            
            // 中指 (12)
            if (isFingerUp(landmarks, 12)) count++;
            
            // 无名指 (16)
            if (isFingerUp(landmarks, 16)) count++;
            
            // 小指 (20)
            if (isFingerUp(landmarks, 20)) count++;
            
            return count;
        }
        
        // Camera 类（简化版，用于 MediaPipe）
        class Camera {
            constructor(outputCanvas, options) {
                this.outputCanvas = outputCanvas;
                this.options = options || {};
                this.video = document.createElement('video');
                this.video.style.display = 'none';
                document.body.appendChild(this.video);
            }
            
            async start() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: this.options.width || 640,
                        height: this.options.height || 480
                    }
                });
                
                this.video.srcObject = stream;
                await this.video.play();
                
                // 将视频绘制到 Canvas
                const ctx = this.outputCanvas.getContext('2d');
                const drawFrame = () => {
                    if (this.video.readyState >= 2) {
                        ctx.drawImage(this.video, 0, 0, this.outputCanvas.width, this.outputCanvas.height);
                        
                        // 调用回调函数
                        if (this.options.onFrame) {
                            this.options.onFrame();
                        }
                    }
                    requestAnimationFrame(drawFrame);
                };
                drawFrame();
                
                return new Promise(resolve => {
                    this.video.onplaying = resolve;
                });
            }
        }
        
        // 初始化应用
        async function initApp() {
            try {
                // 初始化 Three.js
                initThreeJS();
                
                // 初始化 MediaPipe Hands
                await initMediaPipe();
                
                // 开始动画循环
                animate();
                
                console.log('应用初始化完成');
            } catch (error) {
                console.error('初始化失败:', error);
                document.getElementById('loading').innerHTML = 
                    '<h2>初始化错误</h2><p>应用初始化失败: ' + error.message + '</p>';
            }
        }
        
        // 启动应用
        initApp();
    </script>
</body>
</html>
