<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebAR 粒子互动 — Three.js + MediaPipe Hands</title>
  <style>
    html,body{height:100%;margin:0;background:#05060a;color:#bfeef4;font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
    #app{position:fixed;inset:0;display:flex;flex-direction:column}
    #ui{position:absolute;left:12px;top:12px;z-index:20;backdrop-filter:blur(6px);background:rgba(0,0,0,0.2);padding:8px;border-radius:10px}
    button{margin:4px;padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:inherit}
    #camera, #three-canvas{position:absolute;right:12px;bottom:12px;width:160px;height:120px;border-radius:8px;overflow:hidden;border:2px solid rgba(255,255,255,0.04);z-index:15;opacity:0.85}
    #hint{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;z-index:21;background:linear-gradient(90deg,rgba(0,0,0,0.35),rgba(255,255,255,0.02));padding:8px 12px;border-radius:20px}
  </style>

  <!-- Import map to let example modules that use bare specifier "three" resolve correctly -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.152.2/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<div id="app">
  <div id="ui">
    <div>WebAR 粒子互动 — 16,000 粒子 · 青色流体 · 物理驱动</div>
    <div style="font-size:12px;margin-top:6px">手势: 张手(球) / 剪刀(Canvas文字) / 握拳(环) / 食指(星) / 竖拇指(爱心)</div>
    <div style="margin-top:6px"><button id="toggleCam">开启 / 关闭 相机</button><button id="reset">重置 粒子</button></div>
  </div>
  <canvas id="three-canvas"></canvas>
  <video id="camera" autoplay muted playsinline></video>
  <div id="hint">请允许摄像头访问。移动端请横持以获得更好识别。</div>
</div>

<!-- Load MediaPipe non-module scripts (they attach to window) -->
<script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
<script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

<!-- Main module script: uses importmap so example modules that import 'three' work -->
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

// ---------- Config ----------
const PARTICLE_COUNT = 16000; // 16k
const CANVAS = document.getElementById('three-canvas');
const VIDEO = document.getElementById('camera');
const toggleCamBtn = document.getElementById('toggleCam');
const resetBtn = document.getElementById('reset');

// Renderer, scene, camera
const renderer = new THREE.WebGLRenderer({ canvas: CANVAS, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,0,60);

// controls for desktop debugging
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enabled = false; // disabled by default; toggle if needed

// particle system container
const particles = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);
const velocities = new Float32Array(PARTICLE_COUNT * 3);
const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
const colors = new Float32Array(PARTICLE_COUNT * 3);

// init positions randomly in a sphere
for(let i=0;i<PARTICLE_COUNT;i++){
  const i3 = i*3;
  const r = Math.cbrt(Math.random()) * 30; // keep density
  const theta = Math.random()*Math.PI*2;
  const phi = Math.acos(2*Math.random()-1);
  positions[i3] = r*Math.sin(phi)*Math.cos(theta);
  positions[i3+1] = r*Math.sin(phi)*Math.sin(theta);
  positions[i3+2] = r*Math.cos(phi);
  velocities[i3] = velocities[i3+1] = velocities[i3+2] = 0;
  targetPositions[i3] = positions[i3];
  targetPositions[i3+1] = positions[i3+1];
  targetPositions[i3+2] = positions[i3+2];
  // cyan-ish colors with slight variation
  colors[i3]=0.0; colors[i3+1]=0.9 + Math.random()*0.1; colors[i3+2]=0.9 + Math.random()*0.05;
}

particles.setAttribute('position', new THREE.BufferAttribute(positions,3));
particles.setAttribute('color', new THREE.BufferAttribute(colors,3));

const material = new THREE.PointsMaterial({ size: 0.6, vertexColors: true, transparent:true, opacity:0.95, sizeAttenuation:true });
const pointCloud = new THREE.Points(particles, material);
scene.add(pointCloud);

// small rim light
const dir = new THREE.DirectionalLight(0xffffff, 0.4);dir.position.set(1,2,3);scene.add(dir);
const amb = new THREE.AmbientLight(0xffffff,0.15);scene.add(amb);

// helpers for target shapes
function makeSphereTargets(radius=18){
  for(let i=0;i<PARTICLE_COUNT;i++){
    const i3=i*3;
    const u=Math.random();
    const v=Math.random();
    const theta = 2*Math.PI*u;
    const phi = Math.acos(2*v-1);
    const rr = radius * (0.95 + 0.1*Math.random());
    targetPositions[i3] = rr*Math.sin(phi)*Math.cos(theta);
    targetPositions[i3+1] = rr*Math.sin(phi)*Math.sin(theta);
    targetPositions[i3+2] = rr*Math.cos(phi);
  }
}

function makeTorusTargets(radius=18, tube=5){
  for(let i=0;i<PARTICLE_COUNT;i++){
    const i3=i*3;
    const u=Math.random()*Math.PI*2;
    const v=Math.random()*Math.PI*2;
    const R = radius;
    const r = tube * (0.6 + Math.random()*0.8);
    const x = (R + r*Math.cos(v)) * Math.cos(u);
    const y = (R + r*Math.cos(v)) * Math.sin(u);
    const z = r*Math.sin(v);
    targetPositions[i3]=x;targetPositions[i3+1]=y;targetPositions[i3+2]=z;
  }
}

// generate targets from canvas text
function makeTextTargets(text){
  const off = document.createElement('canvas');
  const size = 512; off.width = off.height = size;
  const ctx = off.getContext('2d');
  ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size);
  ctx.font = 'bold 160px sans-serif';
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillStyle='#fff'; ctx.fillText(text, size/2, size/2);
  const img = ctx.getImageData(0,0,size,size).data;
  const pts = [];
  for(let y=0;y<size;y+=2){
    for(let x=0;x<size;x+=2){
      const idx = (y*size + x)*4;
      if(img[idx] > 200){
        const nx = (x/size-0.5)*36; // scale to world
        const ny = -(y/size-0.5)*18;
        pts.push([nx, ny, (Math.random()-0.5)*6]);
      }
    }
  }
  // fallback: if no pixels detected (font/render issues), fill with jittered grid
  if(pts.length === 0){
    for(let y=0;y<40;y++) for(let x=0;x<80;x++) pts.push([(x-40)/80*36, (y-20)/40*18, (Math.random()-0.5)*6]);
  }
  for(let i=0;i<PARTICLE_COUNT;i++){const i3=i*3; const p=pts[i % pts.length]; targetPositions[i3]=p[0]+(Math.random()-0.5)*1.5; targetPositions[i3+1]=p[1]+(Math.random()-0.5)*1.5; targetPositions[i3+2]=p[2];}
}

// star shape procedural
function makeStarTargets(points=5, outer=22, inner=9){
  const verts = [];
  for(let i=0;i<points;i++){
    const a = (i/points)*Math.PI*2;
    const ax = Math.cos(a)*outer, ay=Math.sin(a)*outer;
    verts.push([ax,ay,0]);
    const b=(a+Math.PI/points);
    verts.push([Math.cos(b)*inner, Math.sin(b)*inner, 0]);
  }
  for(let i=0;i<PARTICLE_COUNT;i++){
    const i3=i*3; const t = (i/PARTICLE_COUNT)*verts.length; const idx = Math.floor(t)%verts.length; const next=(idx+1)%verts.length; const frac = t - Math.floor(t);
    const x = THREE.MathUtils.lerp(verts[idx][0], verts[next][0], frac) + (Math.random()-0.5)*1.5;
    const y = THREE.MathUtils.lerp(verts[idx][1], verts[next][1], frac) + (Math.random()-0.5)*1.5;
    targetPositions[i3]=x; targetPositions[i3+1]=y; targetPositions[i3+2]=(Math.random()-0.5)*4;
  }
}

// heart shape parametric
function makeHeartTargets(scale=0.9){
  for(let i=0;i<PARTICLE_COUNT;i++){
    const t = Math.random()*Math.PI*2;
    const x = 16*Math.pow(Math.sin(t),3);
    const y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
    const i3=i*3; targetPositions[i3]=x*scale + (Math.random()-0.5)*1.5; targetPositions[i3+1]=y*scale/1.6 + (Math.random()-0.5)*1.5; targetPositions[i3+2]=(Math.random()-0.5)*4;
  }
}

// utility: explosion impulse when switching shape
function explode(center=[0,0,0], strength=12){
  for(let i=0;i<PARTICLE_COUNT;i++){const i3=i*3; const dx=positions[i3]-center[0]; const dy=positions[i3+1]-center[1]; const dz=positions[i3+2]-center[2]; let d = Math.sqrt(dx*dx+dy*dy+dz*dz)+0.0001; const factor = (1/(1+d/24))*strength; velocities[i3]+=dx/d*factor*(0.6+Math.random()); velocities[i3+1]+=dy/d*factor*(0.6+Math.random()); velocities[i3+2]+=dz/d*factor*(0.6+Math.random()); }
}

// physics parameters
let kSpring=0.08; // spring strength to target
let damping=0.92; // velocity damping
let lastTime = performance.now();

function physicsStep(dt, externalForces=[]){
  for(let i=0;i<PARTICLE_COUNT;i++){
    const i3=i*3;
    const tx = targetPositions[i3], ty=targetPositions[i3+1], tz=targetPositions[i3+2];
    let ax = -kSpring * (positions[i3] - tx);
    let ay = -kSpring * (positions[i3+1] - ty);
    let az = -kSpring * (positions[i3+2] - tz);
    for(const f of externalForces){
      const fx = f[0], fy=f[1], fz=f[2], cx=f[3], cy=f[4], cz=f[5], r=f[6];
      const dx = positions[i3]-cx, dy=positions[i3+1]-cy, dz=positions[i3+2]-cz; const dist = Math.sqrt(dx*dx+dy*dy+dz*dz)+0.0001;
      if(dist < r){ const fall = (1 - dist/r); ax += fx*fall; ay += fy*fall; az += fz*fall; }
    }
    velocities[i3] += ax * dt;
    velocities[i3+1] += ay * dt;
    velocities[i3+2] += az * dt;
    velocities[i3] *= damping;
    velocities[i3+1] *= damping;
    velocities[i3+2] *= damping;
    positions[i3] += velocities[i3] * dt;
    positions[i3+1] += velocities[i3+1] * dt;
    positions[i3+2] += velocities[i3+2] * dt;
  }
  particles.attributes.position.needsUpdate = true;
}

// gesture and hand math
let lastHandCenter = null; let lastHandTime = null; let handSpeed=0;
let currentGesture = 'none';

function landmarksToCenter(landmarks){
  let x=0,y=0,z=0; for(const p of landmarks){x+=p.x; y+=p.y; z+=p.z;} return [x/landmarks.length, y/landmarks.length, z/landmarks.length];
}

function detectGesture(landmarks){
  function extended(tip, pip){ return landmarks[tip].y < landmarks[pip].y - 0.02; }
  const thumbExt = landmarks[4].x < landmarks[3].x - 0.02 || landmarks[4].y < landmarks[3].y - 0.02;
  const idxExt = extended(8,6);
  const midExt = extended(12,10);
  const ringExt = extended(16,14);
  const pinkyExt = extended(20,18);
  if(idxExt && midExt && ringExt && pinkyExt && thumbExt) return 'open';
  if(idxExt && midExt && !ringExt && !pinkyExt) return 'scissors';
  if(!idxExt && !midExt && !ringExt && !pinkyExt) return 'fist';
  if(idxExt && !midExt && !ringExt && !pinkyExt) return 'index';
  if(thumbExt && !idxExt && !midExt && !ringExt && !pinkyExt) return 'thumbs';
  return 'none';
}

// mapping gestures to target generators
const shapeGenerators = {
  'open': ()=>makeSphereTargets(18),
  'scissors': ()=>makeTextTargets('我是 元默'),
  'fist': ()=>makeTorusTargets(18,6),
  'index': ()=>makeStarTargets(5,22,9),
  'thumbs': ()=>makeHeartTargets(1.6)
};
let lastSwitch = 0;
function switchShape(gesture){
  const now = performance.now();
  if(gesture in shapeGenerators && now - lastSwitch > 350){
    explode([0,0,0], 10);
    shapeGenerators[gesture]();
    for(let i=0;i<PARTICLE_COUNT;i++){const i3=i*3; velocities[i3]+= (Math.random()-0.5)*2; velocities[i3+1]+= (Math.random()-0.5)*2; velocities[i3+2]+= (Math.random()-0.5)*2;}
    lastSwitch=now;
  }
}

// MediaPipe integration: use scripts loaded earlier
function loadScript(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s);});}

async function startMediapipe(){
  // hands and camera_utils were loaded as classic scripts earlier; ensure available
  if(typeof Hands === 'undefined' || typeof Camera === 'undefined'){
    document.getElementById('hint').innerText='MediaPipe 加载失败，请检查网络或刷新页面。';
    return;
  }

  const hands = new Hands({locateFile: (file)=>`https://unpkg.com/@mediapipe/hands/${file}`});
  hands.setOptions({maxNumHands:2,minDetectionConfidence:0.7,minTrackingConfidence:0.6});
  hands.onResults(onHandsResults);

  let cam = null;
  try{
    cam = new Camera(VIDEO, { onFrame: async ()=>{ await hands.send({image: VIDEO}); }, width:640, height:480 });
    cam.start();
  }catch(err){ console.warn('相机启动失败',err); document.getElementById('hint').innerText='相机启动失败，浏览器或设备不支持摄像头。'; }

  toggleCamBtn.onclick = ()=>{ if(cam && cam.video){ if(cam.video.paused) cam.video.play(); else cam.video.pause(); }};
}

function onHandsResults(results){
  const now = performance.now();
  if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
    const lm = results.multiHandLandmarks[0];
    const center = landmarksToCenter(lm);
    if(lastHandCenter && lastHandTime){
      const dt = (now - lastHandTime)/1000;
      const dx = (center[0]-lastHandCenter[0]) / dt;
      const dy = (center[1]-lastHandCenter[1]) / dt;
      const dz = (center[2]-lastHandCenter[2]) / dt;
      handSpeed = Math.sqrt(dx*dx+dy*dy+dz*dz);
      if(handSpeed > 1.5){
        const dirx = -dx*80; const diry = dy*80; const dirz = -dz*80;
        const rx = (center[0]-0.5)*-72; const ry = (0.5-center[1])*36; const rz = (center[2]-0.5)*-40;
        lastExternalForces.push([dirx, diry, dirz, rx, ry, rz, 70]);
        explode([rx,ry,rz], 20);
      }
    }
    lastHandCenter = center; lastHandTime = now;
    const bbox = getBoundingBoxArea(lm);
    applyDepthScaling(bbox);
    const gest = detectGesture(lm);
    if(gest !== currentGesture){ currentGesture = gest; switchShape(gest); }
  } else {
    handSpeed = 0; lastHandCenter = null; lastHandTime = null;
  }
}

function getBoundingBoxArea(lm){
  let minx=1,miny=1,maxx=0,maxy=0;
  for(const p of lm){ minx=Math.min(minx,p.x); maxx=Math.max(maxx,p.x); miny=Math.min(miny,p.y); maxy=Math.max(maxy,p.y); }
  const area = (maxx-minx)*(maxy-miny); return area; // normalized
}

// scaling particle system by hand area
let scaleTarget = 1; function applyDepthScaling(area){
  const s = THREE.MathUtils.clamp(0.6 + (area*6.0), 0.6, 1.6);
  scaleTarget = THREE.MathUtils.lerp(scaleTarget, s, 0.08);
  pointCloud.scale.set(scaleTarget, scaleTarget, scaleTarget);
}

// external forces array managed per frame
const lastExternalForces = [];

// main loop
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now(); const dt = Math.min((now-lastTime)/1000, 0.05); lastTime = now;
  const forces = lastExternalForces.splice(0, lastExternalForces.length);
  physicsStep(dt, forces);
  camera.position.z = THREE.MathUtils.lerp(camera.position.z, 55 - Math.min(handSpeed*8,18), 0.06);
  controls.update();
  renderer.render(scene, camera);
}

// UI
resetBtn.onclick = ()=>{ for(let i=0;i<PARTICLE_COUNT;i++){const i3=i*3; positions[i3]= (Math.random()-0.5)*40; positions[i3+1]=(Math.random()-0.5)*40; positions[i3+2]=(Math.random()-0.5)*40; velocities[i3]=velocities[i3+1]=velocities[i3+2]=0; } particles.attributes.position.needsUpdate=true; }

// resize
window.addEventListener('resize', ()=>{renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();});

// start everything
makeSphereTargets(18);
startMediapipe();
animate();

</script>
</body>
</html>
