<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>WebAR GPU Particles (Three.js + TF) - å…ƒé»˜</title>
<style>
  html,body { height:100%; margin:0; background:#000; color:#0ff; font-family: "Microsoft YaHei", sans-serif; }
  #container { position:fixed; inset:0; overflow:hidden; }
  #ui { position:absolute; left:16px; top:16px; z-index:30; pointer-events:none; text-shadow:0 0 8px #00ffff;}
  #status { font-size:14px; }
  #settings { position:absolute; right:16px; top:16px; z-index:30; pointer-events:auto; }
  #fps { position:absolute; right:16px; bottom:16px; z-index:30; color:#0f8; opacity:0.85; }
  #loading { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:999; background:#000; }
  button, input { font-size:13px; }
</style>
</head>
<body>
<div id="container"></div>

<div id="ui">
  <div id="status">åˆå§‹åŒ–...</div>
  <div style="margin-top:8px; font-size:13px;">
    ğŸ– å¼ æ‰‹: çƒä½“ | âœŒ å‰ªåˆ€: æ–‡å­— | âœŠ æ¡æ‹³: åœ†ç¯ | â˜ é£ŸæŒ‡: æ˜Ÿæ˜Ÿ | ğŸ‘ æ‹‡æŒ‡: çˆ±å¿ƒ
  </div>
</div>

<div id="settings">
  <button id="toggle-settings">âš™ è®¾ç½®</button>
  <div id="panel" style="display:none; background:rgba(0,0,0,0.6); border:1px solid #0ff; padding:8px; margin-top:6px;">
    <div>ç²’å­: <span id="pcnt">16000</span></div>
    <input id="particleCount" type="range" min="2000" max="60000" step="1000" value="16000"/><br/>
    <div style="margin-top:6px;"><button id="reset">é‡ç½®é»˜è®¤</button></div>
  </div>
</div>

<div id="fps">FPS: --</div>
<div id="loading"><div style="color:#0ff;">æ­£åœ¨åŠ è½½èµ„æºä¸æ¨¡å‹â€¦</div></div>

<script type="module">
/* å…¨éƒ¨åœ¨å•æ–‡ä»¶å®ç°
   - Three.js è´Ÿè´£æ‘„åƒå¤´æ˜¾ç¤ºä¸ UIï¼ˆæ¸²æŸ“ç©ºåœºæ™¯ï¼Œä»…è·å– canvas/glï¼‰
   - ä½¿ç”¨åŒä¸€ canvas çš„ WebGL2 context åš Transform Feedback compute + particle render
   - MediaPipe Hands ç”¨äºæ‰‹åŠ¿è¯†åˆ«ï¼ˆjsDelivr CDNï¼‰
*/

/* --------------------- é…ç½® --------------------- */
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const CONFIG = {
  particleCount: 16000,
  particleSize: 6.0,          // GL point size (åƒç´ )
  baseDepth: 25.0,
  friction: 0.995,
  spring: 0.02,
  explosionForce: 1.0,
  stormThreshold: 20.0,
  stormForce: 2.5
};

/* --------------------- å…¨å±€å˜é‡ --------------------- */
let container = document.getElementById('container');
let statusEl = document.getElementById('status');
let fpsEl = document.getElementById('fps');
let loadingEl = document.getElementById('loading');
let pcntEl = document.getElementById('pcnt');
let particleSlider = document.getElementById('particleCount');
let settingsBtn = document.getElementById('toggle-settings');
let panel = document.getElementById('panel');

let renderer, scene, camera, video;
let gl; // WebGL2RenderingContext (shared)
let isWebGL2 = false;

// TF resources
let tfPrograms = {};
let buffers = {};
let tfPing = 0;

// GL programs: compute (TF) and render
let computeProgram = null;
let renderProgram = null;

// textures
let targetTex = null;

// MediaPipe
let hands = null;
let handLandmarks = null;
let handSpeed = 0;
let lastWrist = {x:0,y:0,z:0};

/* --------------------- å¸®åŠ©å‡½æ•° (GL ç¼–è¯‘) --------------------- */
function compileShader(gl, src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    const log = gl.getShaderInfoLog(s);
    console.error('Shader compile error', log);
    throw new Error(log);
  }
  return s;
}
function linkProgram(gl, vs, fs, transformFeedbackVaryings=null) {
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  if (fs) gl.attachShader(p, fs);
  if (transformFeedbackVaryings) {
    // æŒ‡å®š varying åç§°ä»¥ä¾¿ TF æ•è·
    gl.transformFeedbackVaryings(p, transformFeedbackVaryings, gl.SEPARATE_ATTRIBS);
  }
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    const log = gl.getProgramInfoLog(p);
    console.error('Program link error', log);
    throw new Error(log);
  }
  return p;
}

/* --------------------- åˆå§‹åŒ– Three.js ï¼ˆå¹¶å…±äº« GLï¼‰ --------------------- */
function initThreeAndGL() {
  // Create WebGLRenderer but do not clear canvas (we'll render both)
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  // Obtain GL context and ensure WebGL2
  gl = renderer.getContext();
  if (!(gl instanceof WebGL2RenderingContext)) {
    alert('éœ€è¦æ”¯æŒ WebGL2 çš„æµè§ˆå™¨ï¼ˆTransform Feedbackï¼‰ã€‚');
    throw new Error('WebGL2 required');
  }
  isWebGL2 = true;

  // Basic scene & camera for background (camera feed will be shown via video texture on three mesh)
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.z = CONFIG.baseDepth;

  // Create a simple plane with video texture to show camera feed (Three.js)
  video = document.createElement('video');
  video.autoplay = true;
  video.playsInline = true;
  video.muted = true;
  video.style.display = 'none';
  document.body.appendChild(video);

  const videoTex = new THREE.VideoTexture(video);
  videoTex.minFilter = THREE.LinearFilter;
  videoTex.magFilter = THREE.LinearFilter;
  videoTex.format = THREE.RGBAFormat;

  const planeGeo = new THREE.PlaneGeometry(16, 9);
  planeGeo.scale(1,1,1);
  const planeMat = new THREE.MeshBasicMaterial({ map: videoTex, toneMapped:false });
  const mesh = new THREE.Mesh(planeGeo, planeMat);
  // Scale to cover viewport
  const aspect = window.innerWidth / window.innerHeight;
  const scale = CONFIG.baseDepth * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * 2;
  mesh.scale.set(scale * aspect, scale, 1);
  scene.add(mesh);

  window.addEventListener('resize', onWindowResize);
}

/* --------------------- WebGL2 Transform Feedback åˆå§‹åŒ– --------------------- */
function initTransformFeedback() {
  // åˆ›å»ºä¸¤ä¸ª buffer å¯¹åº” position.xyzw? We'll store vec4 (x,y,z,w) where w unused
  const N = CONFIG.particleCount;

  buffers.pos = [];
  buffers.vel = [];
  buffers.index = gl.createBuffer();

  // index buffer: store particle index as float for lookup in texture
  const idx = new Float32Array(N);
  for (let i=0;i<N;i++) idx[i] = i + 0.5; // +0.5 to sample texel center
  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.index);
  gl.bufferData(gl.ARRAY_BUFFER, idx, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // create two position buffers (ping/pong) and two velocity buffers
  for (let i=0;i<2;i++) {
    const p = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, p);
    // initial random positions in a cube
    const posArr = new Float32Array(N * 4);
    for (let j=0;j<N;j++) {
      posArr[j*4+0] = (Math.random()-0.5) * 8.0;
      posArr[j*4+1] = (Math.random()-0.5) * 8.0;
      posArr[j*4+2] = (Math.random()-0.5) * 8.0;
      posArr[j*4+3] = 1.0;
    }
    gl.bufferData(gl.ARRAY_BUFFER, posArr, gl.DYNAMIC_COPY);
    buffers.pos.push(p);

    const v = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, v);
    const velArr = new Float32Array(N * 4);
    for (let j=0;j<N;j++) {
      velArr[j*4+0] = 0.0;
      velArr[j*4+1] = 0.0;
      velArr[j*4+2] = 0.0;
      velArr[j*4+3] = 0.0;
    }
    gl.bufferData(gl.ARRAY_BUFFER, velArr, gl.DYNAMIC_COPY);
    buffers.vel.push(v);
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // target texture (stores desired shape positions) - RGBA32F 1D texture (width = N)
  targetTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, targetTex);
  // allocate but empty initially
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, N, 1, 0, gl.RGBA, gl.FLOAT, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.bindTexture(gl.TEXTURE_2D, null);

  // ç¼–è¯‘ compute shader (vertex shader doing TF)
  const computeVS = `#version 300 es
  precision highp float;
  in vec4 a_pos;
  in vec4 a_vel;
  in float a_idx;
  uniform sampler2D u_target;
  uniform float u_dt;
  uniform float u_count;
  uniform float u_spring;
  uniform float u_friction;
  uniform vec3 u_hand; // x,y, speed-scale (z)
  uniform float u_explosion;
  out vec4 v_pos;
  out vec4 v_vel;

  // fetch target by index
  vec3 fetchTarget(float idx) {
    float texX = (idx + 0.5) / u_count;
    vec4 t = texture(u_target, vec2(texX, 0.5));
    return t.xyz;
  }

  void main() {
    vec3 pos = a_pos.xyz;
    vec3 vel = a_vel.xyz;
    vec3 target = fetchTarget(a_idx);

    // spring toward target
    vec3 accel = (target - pos) * u_spring;

    // hand interaction (push if close)
    vec2 diff = pos.xy - u_hand.xy;
    float d2 = dot(diff, diff);
    if (u_hand.z > 0.0 && d2 < 36.0) {
      // repel
      float f = (1.0 - sqrt(d2)/6.0) * u_hand.z * 0.5;
      accel.xy += normalize(diff) * f;
      accel.z += (fract(sin(a_idx)*43758.5453)-0.5) * f * 0.25;
    }

    // explosion random impulse
    if (u_explosion > 0.5) {
      float r1 = fract(sin(a_idx * 12.9898) * 43758.5453);
      float r2 = fract(sin(a_idx * 78.233) * 43758.5453);
      vec3 imp = vec3(r1-0.5, r2-0.5, fract(sin(r1+r2)*12345.0)-0.5) * u_explosion * 4.0;
      accel += imp;
    }

    // integrate Verlet-like (explicit Euler but stable with small dt)
    vel += accel * u_dt;
    vel *= u_friction;
    pos += vel * u_dt;

    v_pos = vec4(pos, 1.0);
    v_vel = vec4(vel, 0.0);

    // gl_Position not used for TF
  }`;

  const vs = compileShader(gl, computeVS, gl.VERTEX_SHADER);
  // no fragment shader for TF program (we won't draw)
  const tfVaryings = ['v_pos', 'v_vel'];
  computeProgram = linkProgram(gl, vs, null, tfVaryings);

  // render program (simple point renderer)
  const renderVS = `#version 300 es
  precision highp float;
  layout(location=0) in vec4 a_position; // from buffer (pos)
  uniform mat4 u_projView;
  uniform float u_pointSize;
  out vec3 v_color;
  void main(){
    vec4 p = u_projView * vec4(a_position.xyz, 1.0);
    gl_Position = p;
    gl_PointSize = u_pointSize;
    // color gradient based on depth
    float z = clamp((a_position.z + 10.0) / 20.0, 0.0, 1.0);
    v_color = mix(vec3(0.0,1.0,1.0), vec3(0.0,0.5,1.0), z);
  }`;
  const renderFS = `#version 300 es
  precision highp float;
  in vec3 v_color;
  out vec4 outColor;
  void main(){
    // circular point (soft)
    vec2 uv = gl_PointCoord - vec2(0.5);
    float r = length(uv);
    float alpha = smoothstep(0.5, 0.0, r);
    outColor = vec4(v_color, alpha);
  }`;
  const rvs = compileShader(gl, renderVS, gl.VERTEX_SHADER);
  const rfs = compileShader(gl, renderFS, gl.FRAGMENT_SHADER);
  renderProgram = linkProgram(gl, rvs, rfs, null);

  // setup VAOs for compute (input) and for render
  tfPrograms.compute = {
    program: computeProgram,
    attribs: {}
  };

  // Render VAO: we'll bind position buffer as ARRAY_BUFFER and draw with gl.drawArrays
  tfPrograms.render = { program: renderProgram };

  // Create VAOs
  // Compute VAO: binds a_pos, a_vel, a_idx and also set transform feedback targets using buffers (done every frame)
  tfPrograms.compute.vao = gl.createVertexArray();
  gl.bindVertexArray(tfPrograms.compute.vao);
  // a_pos (location will be queried)
  // We'll get attribute locations dynamically
  tfPrograms.compute.loc = {
    a_pos: gl.getAttribLocation(computeProgram, 'a_pos'),
    a_vel: gl.getAttribLocation(computeProgram, 'a_vel'),
    a_idx: gl.getAttribLocation(computeProgram, 'a_idx')
  };
  // bind index attribute
  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.index);
  gl.enableVertexAttribArray(tfPrograms.compute.loc.a_idx);
  gl.vertexAttribPointer(tfPrograms.compute.loc.a_idx, 1, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindVertexArray(null);

  // Render VAO
  tfPrograms.render.vao = gl.createVertexArray();
  gl.bindVertexArray(tfPrograms.render.vao);
  const posLoc = gl.getAttribLocation(renderProgram, 'a_position');
  gl.enableVertexAttribArray(posLoc);
  // binding of position buffer will be done each frame
  gl.bindVertexArray(null);

  // Prepare projection-view matrix uniform location
  tfPrograms.render.u_projView = gl.getUniformLocation(renderProgram, 'u_projView');
  tfPrograms.render.u_pointSize = gl.getUniformLocation(renderProgram, 'u_pointSize');

  // Compute uniforms
  tfPrograms.compute.u_target = gl.getUniformLocation(computeProgram, 'u_target');
  tfPrograms.compute.u_dt = gl.getUniformLocation(computeProgram, 'u_dt');
  tfPrograms.compute.u_count = gl.getUniformLocation(computeProgram, 'u_count');
  tfPrograms.compute.u_spring = gl.getUniformLocation(computeProgram, 'u_spring');
  tfPrograms.compute.u_friction = gl.getUniformLocation(computeProgram, 'u_friction');
  tfPrograms.compute.u_hand = gl.getUniformLocation(computeProgram, 'u_hand');
  tfPrograms.compute.u_explosion = gl.getUniformLocation(computeProgram, 'u_explosion');

}

/* --------------------- å½¢çŠ¶ç”Ÿæˆå¹¶ä¸Šä¼ åˆ° targetTex --------------------- */
function uploadTargetShapeFloatArray(arr) {
  // arr : Float32Array length = N*3  (x,y,z)
  const N = CONFIG.particleCount;
  // expand to RGBA float of size N*4
  const rgba = new Float32Array(N * 4);
  for (let i=0;i<N;i++){
    rgba[i*4+0] = arr[i*3+0] || 0.0;
    rgba[i*4+1] = arr[i*3+1] || 0.0;
    rgba[i*4+2] = arr[i*3+2] || 0.0;
    rgba[i*4+3] = 1.0;
  }
  gl.bindTexture(gl.TEXTURE_2D, targetTex);
  gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, N, 1, gl.RGBA, gl.FLOAT, rgba);
  gl.bindTexture(gl.TEXTURE_2D, null);
}

// create some shapes
function makeSpherePoints(N, radius=4.0) {
  const out = new Float32Array(N*3);
  const golden = Math.PI*(3.0-Math.sqrt(5.0));
  for (let i=0;i<N;i++){
    const y = 1 - (i/(N-1))*2;
    const r = Math.sqrt(1 - y*y);
    const theta = golden * i;
    out[i*3+0] = radius * r * Math.cos(theta);
    out[i*3+1] = radius * y;
    out[i*3+2] = radius * r * Math.sin(theta);
  }
  return out;
}

function makeTorusPoints(N, R=5.0, r=1.5) {
  const out = new Float32Array(N*3);
  for (let i=0;i<N;i++){
    const u = Math.random() * Math.PI*2;
    const v = Math.random() * Math.PI*2;
    out[i*3+0] = (R + r * Math.cos(v)) * Math.cos(u);
    out[i*3+1] = (R + r * Math.cos(v)) * Math.sin(u);
    out[i*3+2] = r * Math.sin(v);
  }
  return out;
}

function makeStarPoints(N, outer=5, inner=2.5) {
  const out = new Float32Array(N*3);
  const points = 5;
  for (let i=0;i<N;i++){
    const angle = (i/N) * Math.PI*2;
    const seg = Math.PI*2/points;
    const k = Math.floor(angle/seg);
    const local = angle - k*seg;
    const t = local / (seg/2);
    const r = t < 1 ? outer : inner;
    const finalAngle = k*seg + (t < 1 ? t*seg/2 : seg/2 + (t-1)*seg/2);
    out[i*3+0] = r * Math.cos(finalAngle) * 0.8;
    out[i*3+1] = r * Math.sin(finalAngle) * 0.8;
    out[i*3+2] = (Math.random()-0.5)*1.5;
  }
  return out;
}

function makeHeartPoints(N, scale=0.6) {
  const out = new Float32Array(N*3);
  for (let i=0;i<N;i++){
    const t = Math.random() * Math.PI * 2;
    const x = 16*Math.pow(Math.sin(t),3);
    const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
    out[i*3+0] = x * scale * 0.05;
    out[i*3+1] = -y * scale * 0.05;
    out[i*3+2] = (Math.random()-0.5)*1.5;
  }
  return out;
}

function makeTextPoints(N, text="æˆ‘æ˜¯ å…ƒé»˜") {
  // Render to canvas and sample (like your original function)
  const canvas = document.createElement('canvas');
  canvas.width = 1024; canvas.height = 256;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'black';
  ctx.fillRect(0,0,canvas.width, canvas.height);
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = 'bold 140px "Microsoft YaHei", sans-serif';
  ctx.fillText(text, canvas.width/2, canvas.height/2);
  const img = ctx.getImageData(0,0,canvas.width,canvas.height);
  const pixels = [];
  for (let y=0;y<canvas.height;y+=3){
    for (let x=0;x<canvas.width;x+=3){
      const idx = (y*canvas.width + x)*4;
      if (img.data[idx] > 128) pixels.push([ (x - canvas.width/2)/60, (canvas.height/2 - y)/60 ]);
    }
  }
  const out = new Float32Array(N*3);
  for (let i=0;i<N;i++){
    const p = pixels[i % pixels.length] || [0,0];
    out[i*3+0] = p[0] + (Math.random()-0.5)*0.2;
    out[i*3+1] = p[1] + (Math.random()-0.5)*0.2;
    out[i*3+2] = (Math.random()-0.5)*1.0;
  }
  return out;
}

/* --------------------- ä¸»å¾ªç¯ï¼šcompute (TF) + render --------------------- */
let lastTime = performance.now();
let frameCount = 0;
let fps = 60;
let explosionFlag = 0.0;
function step() {
  requestAnimationFrame(step);

  const now = performance.now();
  const dtMS = Math.min(now - lastTime, 50);
  lastTime = now;
  const dt = dtMS * 0.001;

  // 1) render background via Three.js (video plane)
  // Important: preserve GL state we will use later
  renderer.state.reset(); // ensure Three.js state clean
  renderer.render(scene, camera);

  // 2) compute TF step on GPU
  runComputePass(dt);

  // 3) render particles (raw GL)
  runRenderPass();

  // update FPS
  frameCount++;
  if (now % 1000 < dtMS) {
    // approximate per second
  }
  if (now - (window._lastFpsTime || 0) > 500) {
    fps = Math.round((frameCount*1000)/(now - (window._lastFpsTime || now)));
    fpsEl.textContent = `FPS: ${fps}`;
    frameCount = 0;
    window._lastFpsTime = now;
  }

  // decay explosion
  explosionFlag = Math.max(0.0, explosionFlag - dt*1.5);
}

function runComputePass(dt) {
  const N = CONFIG.particleCount;
  // ping/pong indices
  const read = tfPing;
  const write = 1 - tfPing;
  // bind program
  gl.useProgram(computeProgram);

  // bind VAO for compute (index attr already bound)
  gl.bindVertexArray(tfPrograms.compute.vao);

  // bind pos (read) at location a_pos
  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.pos[read]);
  gl.enableVertexAttribArray(tfPrograms.compute.loc.a_pos);
  gl.vertexAttribPointer(tfPrograms.compute.loc.a_pos, 4, gl.FLOAT, false, 0, 0);

  // bind vel (read)
  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vel[read]);
  gl.enableVertexAttribArray(tfPrograms.compute.loc.a_vel);
  gl.vertexAttribPointer(tfPrograms.compute.loc.a_vel, 4, gl.FLOAT, false, 0, 0);

  // bind transform feedback buffers (write)
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, buffers.pos[write]);
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, buffers.vel[write]);

  // bind target texture
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, targetTex);
  gl.uniform1i(tfPrograms.compute.u_target, 0);
  gl.uniform1f(tfPrograms.compute.u_dt, dt);
  gl.uniform1f(tfPrograms.compute.u_count, N);
  gl.uniform1f(tfPrograms.compute.u_spring, CONFIG.spring);
  gl.uniform1f(tfPrograms.compute.u_friction, CONFIG.friction);

  // hand influence vector (x,y,speedScale)
  let hx=0, hy=0, hz=0;
  if (handLandmarks) {
    const p = handLandmarks[9]; // palm
    const aspect = window.innerWidth / window.innerHeight;
    hx = (0.5 - p.x) * 10.0 * aspect;
    hy = (0.5 - p.y) * 10.0;
    hz = Math.min(handSpeed / 30.0, 4.0);
  }
  gl.uniform3f(tfPrograms.compute.u_hand, hx, hy, hz);
  gl.uniform1f(tfPrograms.compute.u_explosion, explosionFlag);

  // enable rasterizer discard (we do TF only)
  gl.enable(gl.RASTERIZER_DISCARD);

  // begin transform feedback
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, gl.createTransformFeedback());
  gl.beginTransformFeedback(gl.POINTS);

  // draw
  gl.drawArrays(gl.POINTS, 0, N);

  // end TF
  gl.endTransformFeedback();
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

  gl.disable(gl.RASTERIZER_DISCARD);

  // cleanup attribute pointers
  gl.disableVertexAttribArray(tfPrograms.compute.loc.a_pos);
  gl.disableVertexAttribArray(tfPrograms.compute.loc.a_vel);

  // swap pingpong
  tfPing = write;

  // unbind buffers
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.useProgram(null);
  gl.bindVertexArray(null);
}

function runRenderPass() {
  const N = CONFIG.particleCount;
  gl.useProgram(renderProgram);

  // compute projView matrix from three.js camera
  const proj = camera.projectionMatrix.elements;
  const view = camera.matrixWorldInverse.elements;
  // multiply proj * view (column-major in WebGL; THREE uses column-major)
  // build Float32Array(16)
  const projMat = new Float32Array(camera.projectionMatrix.elements);
  const viewMat = new Float32Array(camera.matrixWorldInverse.elements);
  // compute projView = proj * view (mat4 multiply)
  const projView = new Float32Array(16);
  multiplyMat4(projView, projMat, viewMat);
  gl.uniformMatrix4fv(tfPrograms.render.u_projView, false, projView);
  gl.uniform1f(tfPrograms.render.u_pointSize, CONFIG.particleSize);

  // bind VAO for render and bind position buffer (current ping)
  gl.bindVertexArray(tfPrograms.render.vao);
  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.pos[tfPing]);
  const posLoc = gl.getAttribLocation(renderProgram, 'a_position');
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 4, gl.FLOAT, false, 0, 0);

  // enable blending for additive soft look
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

  // draw
  gl.drawArrays(gl.POINTS, 0, N);

  // cleanup
  gl.disable(gl.BLEND);
  gl.disableVertexAttribArray(posLoc);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindVertexArray(null);
  gl.useProgram(null);
}

/* ç®€å•çŸ©é˜µç›¸ä¹˜ (out = a*b) */
function multiplyMat4(out, a, b){
  for (let i=0;i<4;i++){
    for (let j=0;j<4;j++){
      let s=0;
      for (let k=0;k<4;k++){
        s += a[k*4 + j] * b[i*4 + k];
      }
      out[i*4 + j] = s;
    }
  }
}

/* --------------------- MediaPipe Hands åˆå§‹åŒ– --------------------- */
async function initMediaPipeHands() {
  // load scripts
  await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js');
  await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');

  const videoEl = video;
  const handsModule = window;
  hands = new window.Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  hands.onResults(onHandsResults);

  // start camera via MediaPipe Camera util
  const cameraUtils = window.Camera;
  const camera = new cameraUtils(videoEl, {
    onFrame: async () => {
      await hands.send({image: videoEl});
    },
    width: 640,
    height: 480
  });
  await camera.start();
}

/* loadScript helper */
function loadScript(src) {
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = src;
    s.onload = () => resolve();
    s.onerror = (e) => reject(e);
    document.head.appendChild(s);
  });
}

/* Hand results */
function onHandsResults(results) {
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    handLandmarks = results.multiHandLandmarks[0];
    // compute simple wrist speed
    const w = handLandmarks[0];
    const dx = w.x - lastWrist.x;
    const dy = w.y - lastWrist.y;
    const dz = (w.z || 0) - (lastWrist.z || 0);
    const sp = Math.sqrt(dx*dx + dy*dy + dz*dz) / (1/30);
    handSpeed = handSpeed * 0.8 + sp * 0.2;
    lastWrist.x = w.x; lastWrist.y = w.y; lastWrist.z = w.z || 0;

    // gesture detection (robust)
    const g = detectGestureReliable(handLandmarks);
    if (g && g !== currentShapeRequested) {
      currentShapeRequested = g;
      // upload corresponding target texture and set explosion
      triggerShapeSwitch(g);
    }
  } else {
    // no hand
    handLandmarks = null;
    handSpeed = 0;
  }
}

/* --------------------- æ‰‹åŠ¿è¯†åˆ«ï¼šç¨³å®šäº”æ€ ---------------------
   ä½¿ç”¨æ¯æŒ‡æ˜¯å¦ä¼¸ç›´ï¼ˆåŸºäº tip-y ä¸ pip-y æˆ–å‘é‡å¤¹è§’ï¼‰åˆ¤æ–­ã€‚
   è¿”å›: 'sphere','torus','star','heart','text'
*/
function isFingerExtended(lm, tip, pip) {
  // ä»¥ tip.y < pip.y (å±å¹•åæ ‡ y ä¸‹å¢) ä¸ºä¼¸ç›´ï¼ˆé€‚å½“å¾®è°ƒï¼‰
  // æ³¨æ„ï¼šMediaPipe åæ ‡åŸç‚¹åœ¨å·¦ä¸Šè§’ï¼Œy å‘ä¸‹å¢
  return lm[tip].y < lm[pip].y - 0.02;
}

let currentShapeRequested = 'sphere';
function detectGestureReliable(lm) {
  // indices: thumb tip=4, index=8, middle=12, ring=16, pinky=20
  const thumbExt = isFingerExtended(lm, 4, 3);
  const indexExt = isFingerExtended(lm, 8, 6);
  const middleExt = isFingerExtended(lm, 12,10);
  const ringExt = isFingerExtended(lm, 16,14);
  const pinkyExt = isFingerExtended(lm, 20,18);

  // thumb-only => heart
  if (thumbExt && !indexExt && !middleExt && !ringExt && !pinkyExt) return 'heart';
  // index-only => star
  if (!thumbExt && indexExt && !middleExt && !ringExt && !pinkyExt) return 'star';
  // index+middle => text
  if (!thumbExt && indexExt && middleExt && !ringExt && !pinkyExt) return 'text';
  // all four fingers extended (index..pinky) => sphere
  if (!thumbExt && indexExt && middleExt && ringExt && pinkyExt) return 'sphere';
  // closed fist => torus
  if (!thumbExt && !indexExt && !middleExt && !ringExt && !pinkyExt) return 'torus';
  // fallback keep current
  return null;
}

/* --------------------- å½¢çŠ¶åˆ‡æ¢è§¦å‘ --------------------- */
let shapeMap = {};
function triggerShapeSwitch(shapeName) {
  statusEl.textContent = 'åˆ‡æ¢: ' + shapeName;
  // Small visual cue
  setTimeout(()=> statusEl.textContent = 'ç³»ç»Ÿå°±ç»ª', 800);

  switch(shapeName) {
    case 'sphere':
      uploadTargetShapeFloatArray(shapeMap.sphere);
      break;
    case 'torus':
      uploadTargetShapeFloatArray(shapeMap.torus);
      break;
    case 'star':
      uploadTargetShapeFloatArray(shapeMap.star);
      break;
    case 'heart':
      uploadTargetShapeFloatArray(shapeMap.heart);
      break;
    case 'text':
      uploadTargetShapeFloatArray(shapeMap.text);
      break;
    default:
      uploadTargetShapeFloatArray(shapeMap.sphere);
  }
  // small explosion impulse
  explosionFlag = 1.0;
}

/* --------------------- UI æ§ä»¶ --------------------- */
particleSlider.addEventListener('input', (e)=>{
  pcntEl.textContent = e.target.value;
});
settingsBtn.addEventListener('click', ()=> {
  panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
});
document.getElementById('reset').addEventListener('click', ()=>{
  particleSlider.value = CONFIG.particleCount = 16000;
  pcntEl.textContent = CONFIG.particleCount;
  location.reload();
});

/* --------------------- å¯åŠ¨åˆå§‹åŒ– --------------------- */
async function start() {
  try {
    pcntEl.textContent = CONFIG.particleCount;
    statusEl.textContent = 'åˆå§‹åŒ– Three.js ä¸ GL';
    initThreeAndGL();

    statusEl.textContent = 'åˆå§‹åŒ– Transform Feedback';
    initTransformFeedback();

    statusEl.textContent = 'ç”Ÿæˆå½¢çŠ¶';
    const N = CONFIG.particleCount;
    shapeMap.sphere = makeSpherePoints(N, 5.0);
    shapeMap.torus = makeTorusPoints(N, 6.0, 2.0);
    shapeMap.star = makeStarPoints(N, 5.0, 2.5);
    shapeMap.heart = makeHeartPoints(N, 0.6);
    shapeMap.text = makeTextPoints(N, 'æˆ‘æ˜¯ å…ƒé»˜');
    // upload default
    uploadTargetShapeFloatArray(shapeMap.sphere);

    statusEl.textContent = 'è¯·æ±‚æ‘„åƒå¤´æƒé™';
    // request camera via getUserMedia for video element used by MediaPipe
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
    video.srcObject = stream;
    await video.play();

    statusEl.textContent = 'åˆå§‹åŒ– MediaPipe Hands';
    await initMediaPipeHands();

    // hide loading
    loadingEl.style.display = 'none';
    statusEl.textContent = 'ç³»ç»Ÿå°±ç»ª';

    // start loop
    requestAnimationFrame(step);
  } catch (err) {
    console.error(err);
    alert('åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°: ' + err.message);
  }
}

/* --------------------- å¯åŠ¨ --------------------- */
start();

/* --------------------- å…¶ä»–å°å·¥å…· --------------------- */
// ç”¨äºæ‰‹åŠ¨è§¦å‘çˆ†ç‚¸ï¼ˆæ–¹ä¾¿è°ƒè¯•ï¼‰
window.addEventListener('keydown', (e)=> {
  if (e.key === ' ') explosionFlag = 1.5;
});

window.addEventListener('visibilitychange', ()=>{
  // pause rendering if needed
});

</script>
</body>
</html>
