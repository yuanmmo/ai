<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ‰‹åŠ¿ç²’å­äº’åŠ¨ç³»ç»Ÿ - WebARä½“éªŒ</title>
    <script src="https://unpkg.com/three@0.143.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.143.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675465719/camera_utils.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
            touch-action: none;
            user-select: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #webgl-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        
        #input-video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transform: scaleX(-1);
        }
        
        #canvas-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            pointer-events: none;
        }
        
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 30, 40, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 16px;
            max-width: 300px;
            border: 1px solid rgba(0, 200, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .ui-title {
            font-size: 18px;
            margin-bottom: 12px;
            color: #0ff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            border-bottom: 1px solid rgba(0, 200, 255, 0.3);
            padding-bottom: 8px;
        }
        
        .status-item {
            margin-bottom: 8px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }
        
        .status-label {
            color: #8af;
        }
        
        .status-value {
            color: #0ff;
            font-weight: bold;
        }
        
        .gesture-list {
            margin-top: 12px;
            list-style-type: none;
        }
        
        .gesture-item {
            padding: 6px 10px;
            margin-bottom: 6px;
            background: rgba(0, 50, 70, 0.5);
            border-radius: 8px;
            font-size: 13px;
            border-left: 3px solid #0af;
            transition: all 0.3s;
        }
        
        .gesture-item.active {
            background: rgba(0, 100, 150, 0.7);
            border-left: 3px solid #0ff;
            color: #0ff;
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.5);
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s;
        }
        
        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(0, 100, 150, 0.3);
            border-top: 4px solid #0ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 18px;
            color: #0ff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }
        
        .loading-subtext {
            font-size: 14px;
            color: #8af;
            margin-top: 10px;
            text-align: center;
            max-width: 80%;
        }
        
        #hand-status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 30, 40, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 12px 16px;
            border: 1px solid rgba(0, 200, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            font-size: 14px;
            color: #0ff;
        }
        
        #hand-status.hand-detected {
            border-color: #0f0;
            color: #0f0;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0); }
        }
        
        .hand-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 8px;
            background: rgba(0, 255, 0, 0.2);
            border-radius: 50%;
            vertical-align: middle;
        }
        
        .hand-icon.hand-detected {
            background: #0f0;
            box-shadow: 0 0 10px #0f0;
        }
        
        @media (max-width: 768px) {
            .ui-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 12px;
            }
            
            #hand-status {
                bottom: 10px;
                right: 10px;
                left: 10px;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="webgl-canvas"></canvas>
        
        <div id="video-container">
            <video id="input-video" autoplay playsinline></video>
            <canvas id="canvas-overlay"></canvas>
        </div>
        
        <div id="loading">
            <div class="loader"></div>
            <div class="loading-text">åŠ è½½ç²’å­äº’åŠ¨ç³»ç»Ÿ</div>
            <div class="loading-subtext">è¯·å…è®¸è®¿é—®æ‘„åƒå¤´ä»¥è¿›è¡Œæ‰‹åŠ¿è¯†åˆ«<br>æ­£åœ¨åˆå§‹åŒ–16000ä¸ªæµä½“ç²’å­...</div>
        </div>
        
        <div class="ui-panel">
            <div class="ui-title">æ‰‹åŠ¿ç²’å­äº’åŠ¨ç³»ç»Ÿ</div>
            <div class="status-item">
                <span class="status-label">ç²’å­æ•°é‡</span>
                <span class="status-value">16,000</span>
            </div>
            <div class="status-item">
                <span class="status-label">ç‰©ç†æ¨¡å‹</span>
                <span class="status-value">é€Ÿåº¦+åŠ é€Ÿåº¦</span>
            </div>
            <div class="status-item">
                <span class="status-label">å½“å‰æ‰‹åŠ¿</span>
                <span class="status-value" id="current-gesture">ç­‰å¾…è¯†åˆ«</span>
            </div>
            <div class="status-item">
                <span class="status-label">æ‰‹æŒå æ¯”</span>
                <span class="status-value" id="hand-size">0%</span>
            </div>
            
            <ul class="gesture-list">
                <li class="gesture-item" id="gesture-open">ğŸ–ï¸ å¼ æ‰‹ - çƒå½¢ç²’å­</li>
                <li class="gesture-item" id="gesture-scissors">âœŒï¸ å‰ªåˆ€æ‰‹ - "æˆ‘æ˜¯ å…ƒé»˜"æ–‡å­—</li>
                <li class="gesture-item" id="gesture-fist">âœŠ æ¡æ‹³ - åœ†ç¯å½¢æ€</li>
                <li class="gesture-item" id="gesture-point">ğŸ‘† é£ŸæŒ‡ - æ˜Ÿå½¢ç²’å­</li>
                <li class="gesture-item" id="gesture-thumb">ğŸ‘ ç«–å¤§æ‹‡æŒ‡ - çˆ±å¿ƒç²’å­</li>
            </ul>
        </div>
        
        <div id="hand-status">
            <span class="hand-icon"></span>
            <span id="hand-status-text">ç­‰å¾…æ‰‹éƒ¨æ£€æµ‹</span>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let camera, scene, renderer, particles, controls;
        let videoElement, canvasElement, overlayCtx;
        let handDetector = null;
        let lastHandPosition = null;
        let handSpeed = 0;
        let currentGesture = "none";
        let targetShape = "sphere";
        let lastGestureChange = 0;
        let particlesGeometry, particlesMaterial;
        let particlePositions, particleVelocities, particleAccelerations;
        let particleTargets;
        let handDetected = false;
        let handBoundingBox = { width: 0, height: 0, x: 0, y: 0 };
        
        // å¸¸é‡
        const PARTICLE_COUNT = 16000;
        const GESTURE_TRANSITION_TIME = 1000; // è¿‡æ¸¡æ—¶é—´(ms)
        const WIND_FORCE_MULTIPLIER = 0.5;
        const HAND_SIZE_MULTIPLIER = 0.5;
        const ATTRACTION_FORCE = 0.05;
        const REPULSION_FORCE = 0.1;
        const DAMPING = 0.95;
        
        // åˆå§‹åŒ–Three.jsåœºæ™¯
        function initThreeJS() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000011, 10, 100);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('webgl-canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0);
            
            // æ·»åŠ è½¨é“æ§åˆ¶ï¼ˆä»…ç”¨äºè°ƒè¯•ï¼‰
            // controls = new THREE.OrbitControls(camera, renderer.domElement);
            // controls.enableDamping = true;
            
            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x222244);
            scene.add(ambientLight);
            
            // æ·»åŠ æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0x88aaff, 0.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticles();
            
            // å“åº”çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', onWindowResize);
            
            // éšè—åŠ è½½ç•Œé¢
            setTimeout(() => {
                document.getElementById('loading').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            }, 1500);
        }
        
        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        function createParticles() {
            // åˆ›å»ºç²’å­å‡ ä½•ä½“
            particlesGeometry = new THREE.BufferGeometry();
            
            // åˆå§‹åŒ–ç²’å­ä½ç½®ã€é€Ÿåº¦å’ŒåŠ é€Ÿåº¦æ•°ç»„
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const velocities = new Float32Array(PARTICLE_COUNT * 3);
            const accelerations = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);
            
            // ç›®æ ‡ä½ç½®æ•°ç»„
            particleTargets = new Float32Array(PARTICLE_COUNT * 3);
            
            // åˆå§‹åŒ–æ‰€æœ‰ç²’å­
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // éšæœºä½ç½®ï¼ˆçƒä½“åˆ†å¸ƒï¼‰
                const i3 = i * 3;
                const radius = 2 + Math.random() * 4;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                
                // åˆå§‹ç›®æ ‡ä½ç½®ä¸å½“å‰ä½ç½®ç›¸åŒ
                particleTargets[i3] = positions[i3];
                particleTargets[i3 + 1] = positions[i3 + 1];
                particleTargets[i3 + 2] = positions[i3 + 2];
                
                // åˆå§‹é€Ÿåº¦ä¸ºé›¶
                velocities[i3] = 0;
                velocities[i3 + 1] = 0;
                velocities[i3 + 2] = 0;
                
                // åˆå§‹åŠ é€Ÿåº¦ä¸ºé›¶
                accelerations[i3] = 0;
                accelerations[i3 + 1] = 0;
                accelerations[i3 + 2] = 0;
                
                // é’è‰²ç²’å­é¢œè‰²
                colors[i3] = 0.0;      // R
                colors[i3 + 1] = 0.8 + Math.random() * 0.2;  // G
                colors[i3 + 2] = 0.8 + Math.random() * 0.2;  // B
                
                // ç²’å­å¤§å°
                sizes[i] = 0.05 + Math.random() * 0.05;
            }
            
            // è®¾ç½®å‡ ä½•ä½“å±æ€§
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // åˆ›å»ºç²’å­æè´¨
            particlesMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);
            
            // ä¿å­˜ä¸ºå…¨å±€å˜é‡ä»¥ä¾¿åœ¨åŠ¨ç”»å¾ªç¯ä¸­è®¿é—®
            particlePositions = particlesGeometry.attributes.position.array;
            particleVelocities = velocities;
            particleAccelerations = accelerations;
        }
        
        // åˆå§‹åŒ–MediaPipe Hands
        async function initHandDetection() {
            videoElement = document.getElementById('input-video');
            canvasElement = document.getElementById('canvas-overlay');
            overlayCtx = canvasElement.getContext('2d');
            
            // è®¾ç½®canvaså°ºå¯¸
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            
            // åˆ›å»ºHandsæ£€æµ‹å™¨
            handDetector = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                }
            });
            
            // é…ç½®Handså‚æ•°
            handDetector.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            // è®¾ç½®æ£€æµ‹ç»“æœå›è°ƒ
            handDetector.onResults(onHandResults);
            
            // å¯åŠ¨æ‘„åƒå¤´
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await handDetector.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            await camera.start();
        }
        
        // å¤„ç†æ‰‹éƒ¨æ£€æµ‹ç»“æœ
        function onHandResults(results) {
            // æ¸…é™¤è¦†ç›–å±‚
            overlayCtx.save();
            overlayCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            overlayCtx.scale(-1, 1);
            overlayCtx.translate(-canvasElement.width, 0);
            
            // ç»˜åˆ¶æ£€æµ‹åˆ°çš„åœ°æ ‡
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                document.getElementById('hand-status').classList.add('hand-detected');
                document.querySelector('.hand-icon').classList.add('hand-detected');
                document.getElementById('hand-status-text').textContent = "æ‰‹éƒ¨å·²æ£€æµ‹åˆ°";
                
                // è·å–ç¬¬ä¸€åªæ‰‹çš„åœ°æ ‡
                const landmarks = results.multiHandLandmarks[0];
                const handedness = results.multiHandWorldLandmarks ? results.multiHandedness[0] : { label: 'Unknown' };
                
                // è®¡ç®—æ‰‹éƒ¨è¾¹ç•Œæ¡†
                calculateHandBoundingBox(landmarks);
                
                // æ£€æµ‹æ‰‹åŠ¿
                detectGesture(landmarks, handedness);
                
                // è®¡ç®—æ‰‹éƒ¨é€Ÿåº¦
                calculateHandSpeed(landmarks);
                
                // ç»˜åˆ¶æ‰‹éƒ¨åœ°æ ‡
                drawHandLandmarks(landmarks);
            } else {
                handDetected = false;
                document.getElementById('hand-status').classList.remove('hand-detected');
                document.querySelector('.hand-icon').classList.remove('hand-detected');
                document.getElementById('hand-status-text').textContent = "ç­‰å¾…æ‰‹éƒ¨æ£€æµ‹";
                currentGesture = "none";
                document.getElementById('current-gesture').textContent = "ç­‰å¾…è¯†åˆ«";
            }
            
            overlayCtx.restore();
        }
        
        // è®¡ç®—æ‰‹éƒ¨è¾¹ç•Œæ¡†
        function calculateHandBoundingBox(landmarks) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            landmarks.forEach(landmark => {
                const x = landmark.x * canvasElement.width;
                const y = landmark.y * canvasElement.height;
                
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
            });
            
            handBoundingBox = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
            
            // è®¡ç®—æ‰‹æŒå æ¯”ï¼ˆç›¸å¯¹äºå±å¹•ï¼‰
            const handArea = handBoundingBox.width * handBoundingBox.height;
            const screenArea = canvasElement.width * canvasElement.height;
            const handPercentage = Math.min(100, Math.round((handArea / screenArea) * 100 * 100));
            
            document.getElementById('hand-size').textContent = handPercentage + "%";
            
            // æ ¹æ®æ‰‹æŒå æ¯”è°ƒæ•´ç²’å­ç³»ç»Ÿç¼©æ”¾
            adjustParticleScale(handPercentage);
        }
        
        // æ ¹æ®æ‰‹æŒå æ¯”è°ƒæ•´ç²’å­ç³»ç»Ÿç¼©æ”¾
        function adjustParticleScale(percentage) {
            // å°†ç™¾åˆ†æ¯”è½¬æ¢ä¸ºç¼©æ”¾å› å­ (0.5 åˆ° 2.0)
            const scale = 0.5 + (percentage / 100) * 1.5;
            particles.scale.setScalar(scale);
        }
        
        // æ£€æµ‹æ‰‹åŠ¿
        function detectGesture(landmarks, handedness) {
            // è·å–å…³é”®ç‚¹
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            
            // è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
            const distance = (p1, p2) => {
                return Math.sqrt(
                    Math.pow(p1.x - p2.x, 2) + 
                    Math.pow(p1.y - p2.y, 2) + 
                    Math.pow(p1.z - p2.z, 2)
                );
            };
            
            // è®¡ç®—æŒ‡å°–æ˜¯å¦å¼ å¼€
            const isFingerExtended = (tip, pip) => {
                return tip.y < pip.y;  // æŒ‡å°–çš„yåæ ‡å°äºæŒ‡èŠ‚çš„yåæ ‡ï¼ˆå› ä¸ºåæ ‡ç³»åŸç‚¹åœ¨å·¦ä¸Šè§’ï¼‰
            };
            
            // è·å–æ‰‹æŒ‡çš„PIPï¼ˆç¬¬äºŒæŒ‡èŠ‚ï¼‰ç‚¹
            const thumbPip = landmarks[2];
            const indexPip = landmarks[6];
            const middlePip = landmarks[10];
            const ringPip = landmarks[14];
            const pinkyPip = landmarks[18];
            
            // æ£€æŸ¥æ¯ä¸ªæ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´
            const thumbExtended = isFingerExtended(thumbTip, thumbPip);
            const indexExtended = isFingerExtended(indexTip, indexPip);
            const middleExtended = isFingerExtended(middleTip, middlePip);
            const ringExtended = isFingerExtended(ringTip, ringPip);
            const pinkyExtended = isFingerExtended(pinkyTip, pinkyPip);
            
            // æ‰‹åŠ¿è¯†åˆ«
            let gesture = "unknown";
            
            // å¼ æ‰‹ï¼šæ‰€æœ‰æ‰‹æŒ‡ä¼¸ç›´
            if (indexExtended && middleExtended && ringExtended && pinkyExtended && thumbExtended) {
                gesture = "open";
            }
            // å‰ªåˆ€æ‰‹ï¼šé£ŸæŒ‡å’Œä¸­æŒ‡ä¼¸ç›´ï¼Œå…¶ä»–æ‰‹æŒ‡å¼¯æ›²
            else if (indexExtended && middleExtended && !ringExtended && !pinkyExtended) {
                gesture = "scissors";
            }
            // æ¡æ‹³ï¼šæ‰€æœ‰æ‰‹æŒ‡å¼¯æ›²
            else if (!indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                gesture = "fist";
            }
            // é£ŸæŒ‡ï¼šåªæœ‰é£ŸæŒ‡ä¼¸ç›´
            else if (indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                gesture = "point";
            }
            // ç«–å¤§æ‹‡æŒ‡ï¼šåªæœ‰å¤§æ‹‡æŒ‡ä¼¸ç›´
            else if (thumbExtended && !indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                gesture = "thumb";
            }
            
            // æ›´æ–°å½“å‰æ‰‹åŠ¿
            if (gesture !== currentGesture && gesture !== "unknown") {
                currentGesture = gesture;
                document.getElementById('current-gesture').textContent = getGestureName(gesture);
                
                // è§¦å‘çˆ†ç‚¸è¿‡æ¸¡æ•ˆæœ
                triggerExplosionTransition();
                
                // æ›´æ–°ç›®æ ‡å½¢çŠ¶
                updateTargetShape(gesture);
                
                // æ›´æ–°UIé«˜äº®
                updateGestureUI(gesture);
                
                lastGestureChange = Date.now();
            }
        }
        
        // è·å–æ‰‹åŠ¿åç§°
        function getGestureName(gesture) {
            switch(gesture) {
                case "open": return "å¼ æ‰‹";
                case "scissors": return "å‰ªåˆ€æ‰‹";
                case "fist": return "æ¡æ‹³";
                case "point": return "é£ŸæŒ‡";
                case "thumb": return "ç«–å¤§æ‹‡æŒ‡";
                default: return "æœªçŸ¥";
            }
        }
        
        // æ›´æ–°UIæ‰‹åŠ¿é«˜äº®
        function updateGestureUI(gesture) {
            // ç§»é™¤æ‰€æœ‰é«˜äº®
            document.querySelectorAll('.gesture-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // æ·»åŠ å½“å‰æ‰‹åŠ¿é«˜äº®
            document.getElementById(`gesture-${gesture}`).classList.add('active');
        }
        
        // è§¦å‘çˆ†ç‚¸è¿‡æ¸¡æ•ˆæœ
        function triggerExplosionTransition() {
            // ç»™æ‰€æœ‰ç²’å­ä¸€ä¸ªå‘å¤–çˆ†ç‚¸çš„é€Ÿåº¦
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // è·å–å½“å‰ä½ç½®
                const x = particlePositions[i3];
                const y = particlePositions[i3 + 1];
                const z = particlePositions[i3 + 2];
                
                // è®¡ç®—ä»ä¸­å¿ƒæŒ‡å‘ç²’å­çš„æ–¹å‘
                const distance = Math.sqrt(x*x + y*y + z*z);
                const dirX = distance > 0 ? x / distance : 0;
                const dirY = distance > 0 ? y / distance : 0;
                const dirZ = distance > 0 ? z / distance : 0;
                
                // æ–½åŠ çˆ†ç‚¸åŠ›ï¼ˆå‘å¤–ï¼‰
                const explosionForce = 0.5;
                particleVelocities[i3] += dirX * explosionForce;
                particleVelocities[i3 + 1] += dirY * explosionForce;
                particleVelocities[i3 + 2] += dirZ * explosionForce;
            }
        }
        
        // æ ¹æ®æ‰‹åŠ¿æ›´æ–°ç›®æ ‡å½¢çŠ¶
        function updateTargetShape(gesture) {
            switch(gesture) {
                case "open":
                    targetShape = "sphere";
                    break;
                case "scissors":
                    targetShape = "text";
                    generateTextTargets();
                    break;
                case "fist":
                    targetShape = "ring";
                    break;
                case "point":
                    targetShape = "star";
                    break;
                case "thumb":
                    targetShape = "heart";
                    break;
                default:
                    targetShape = "sphere";
            }
        }
        
        // ç”Ÿæˆæ–‡å­—ç›®æ ‡ä½ç½®
        function generateTextTargets() {
            // åˆ›å»ºä¸´æ—¶canvasæ¥ç»˜åˆ¶æ–‡å­—
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // æ¸…é™¤canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = 'white';
            ctx.font = 'bold 40px "Microsoft YaHei", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('æˆ‘æ˜¯ å…ƒé»˜', canvas.width/2, canvas.height/2);
            
            // è·å–åƒç´ æ•°æ®
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // æ‰¾å‡ºæ‰€æœ‰éé€æ˜åƒç´ çš„ä½ç½®
            const textPoints = [];
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    if (data[index + 3] > 128) { // éé€æ˜åƒç´ 
                        // å°†2Dåæ ‡è½¬æ¢ä¸º3Dåæ ‡
                        const px = (x / canvas.width - 0.5) * 10;
                        const py = (0.5 - y / canvas.height) * 10;
                        const pz = 0;
                        textPoints.push([px, py, pz]);
                    }
                }
            }
            
            // å¦‚æœæ–‡å­—ç‚¹å¤ªå°‘ï¼Œæ·»åŠ ä¸€äº›éšæœºç‚¹
            if (textPoints.length < PARTICLE_COUNT) {
                const needed = PARTICLE_COUNT - textPoints.length;
                for (let i = 0; i < needed; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 2 + Math.random() * 3;
                    textPoints.push([
                        radius * Math.cos(angle),
                        radius * Math.sin(angle),
                        (Math.random() - 0.5) * 2
                    ]);
                }
            }
            
            // ä¸ºæ¯ä¸ªç²’å­åˆ†é…ä¸€ä¸ªç›®æ ‡ä½ç½®
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const pointIndex = Math.floor(Math.random() * textPoints.length);
                const point = textPoints[pointIndex];
                
                particleTargets[i3] = point[0];
                particleTargets[i3 + 1] = point[1];
                particleTargets[i3 + 2] = point[2];
            }
        }
        
        // è®¡ç®—æ‰‹éƒ¨é€Ÿåº¦
        function calculateHandSpeed(landmarks) {
            const wrist = landmarks[0];
            const currentPosition = { x: wrist.x, y: wrist.y, z: wrist.z };
            
            if (lastHandPosition) {
                // è®¡ç®—è·ç¦»
                const dx = currentPosition.x - lastHandPosition.x;
                const dy = currentPosition.y - lastHandPosition.y;
                const dz = currentPosition.z - lastHandPosition.z;
                
                // è®¡ç®—é€Ÿåº¦ï¼ˆæ¬§æ°è·ç¦»ï¼‰
                handSpeed = Math.sqrt(dx*dx + dy*dy + dz*dz) * 100;
                
                // å¦‚æœé€Ÿåº¦è¶³å¤Ÿå¿«ï¼Œè§¦å‘é£æš´æ•ˆæœ
                if (handSpeed > 0.5) {
                    applyWindForce(currentPosition, lastHandPosition);
                }
            }
            
            lastHandPosition = currentPosition;
        }
        
        // åº”ç”¨é£åŠ›æ•ˆæœï¼ˆæŒ¥æ‰‹é£æš´ï¼‰
        function applyWindForce(currentPos, lastPos) {
            // è®¡ç®—æ‰‹éƒ¨ç§»åŠ¨æ–¹å‘
            const dx = currentPos.x - lastPos.x;
            const dy = currentPos.y - lastPos.y;
            const dz = currentPos.z - lastPos.z;
            
            // å½’ä¸€åŒ–æ–¹å‘å‘é‡
            const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
            if (length === 0) return;
            
            const dirX = dx / length;
            const dirY = dy / length;
            const dirZ = dz / length;
            
            // å°†2Då±å¹•åæ ‡è½¬æ¢ä¸º3Dä¸–ç•Œåæ ‡
            const worldX = (currentPos.x - 0.5) * 20;
            const worldY = (0.5 - currentPos.y) * 20;
            const worldZ = 0;
            
            // å¯¹æ¯ä¸ªç²’å­åº”ç”¨é£åŠ›
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // è·å–ç²’å­ä½ç½®
                const px = particlePositions[i3];
                const py = particlePositions[i3 + 1];
                const pz = particlePositions[i3 + 2];
                
                // è®¡ç®—ç²’å­åˆ°æ‰‹éƒ¨çš„è·ç¦»
                const distX = px - worldX;
                const distY = py - worldY;
                const distZ = pz - worldZ;
                const distance = Math.sqrt(distX*distX + distY*distY + distZ*distZ);
                
                // è·ç¦»è¶Šè¿‘ï¼Œé£åŠ›è¶Šå¼º
                if (distance < 10) {
                    const force = (1 - distance/10) * handSpeed * WIND_FORCE_MULTIPLIER;
                    
                    particleAccelerations[i3] += dirX * force;
                    particleAccelerations[i3 + 1] += dirY * force;
                    particleAccelerations[i3 + 2] += dirZ * force * 0.5; // Zè½´é£åŠ›å‡å¼±
                }
            }
        }
        
        // ç»˜åˆ¶æ‰‹éƒ¨åœ°æ ‡
        function drawHandLandmarks(landmarks) {
            overlayCtx.strokeStyle = '#0ff';
            overlayCtx.lineWidth = 2;
            overlayCtx.fillStyle = 'rgba(0, 255, 255, 0.5)';
            
            // ç»˜åˆ¶è¿æ¥çº¿
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // æ‹‡æŒ‡
                [0, 5], [5, 6], [6, 7], [7, 8], // é£ŸæŒ‡
                [0, 9], [9, 10], [10, 11], [11, 12], // ä¸­æŒ‡
                [0, 13], [13, 14], [14, 15], [15, 16], // æ— åæŒ‡
                [0, 17], [17, 18], [18, 19], [19, 20], // å°æŒ‡
                [5, 9], [9, 13], [13, 17] // æ‰‹æŒ
            ];
            
            connections.forEach(connection => {
                const [start, end] = connection;
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                overlayCtx.beginPath();
                overlayCtx.moveTo(startPoint.x * canvasElement.width, startPoint.y * canvasElement.height);
                overlayCtx.lineTo(endPoint.x * canvasElement.width, endPoint.y * canvasElement.height);
                overlayCtx.stroke();
            });
            
            // ç»˜åˆ¶åœ°æ ‡ç‚¹
            landmarks.forEach(landmark => {
                overlayCtx.beginPath();
                overlayCtx.arc(
                    landmark.x * canvasElement.width,
                    landmark.y * canvasElement.height,
                    4, 0, Math.PI * 2
                );
                overlayCtx.fill();
            });
        }
        
        // æ›´æ–°ç²’å­ç‰©ç†
        function updateParticlePhysics() {
            const time = Date.now();
            const timeSinceGestureChange = time - lastGestureChange;
            const transitionProgress = Math.min(1, timeSinceGestureChange / GESTURE_TRANSITION_TIME);
            
            // æ›´æ–°æ¯ä¸ªç²’å­çš„ç‰©ç†çŠ¶æ€
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // æ ¹æ®å½“å‰æ‰‹åŠ¿è®¡ç®—ç›®æ ‡ä½ç½®
                let targetX, targetY, targetZ;
                
                if (targetShape === "sphere") {
                    // çƒå½¢ï¼šå‡åŒ€åˆ†å¸ƒåœ¨çƒä½“è¡¨é¢
                    const angle = (i % 100) / 100 * Math.PI * 2;
                    const radius = 3 + Math.sin(i * 0.01) * 0.5;
                    const verticalAngle = (i / PARTICLE_COUNT) * Math.PI;
                    
                    targetX = radius * Math.sin(verticalAngle) * Math.cos(angle);
                    targetY = radius * Math.sin(verticalAngle) * Math.sin(angle);
                    targetZ = radius * Math.cos(verticalAngle);
                }
                else if (targetShape === "ring") {
                    // åœ†ç¯ï¼šå‡åŒ€åˆ†å¸ƒåœ¨åœ†ç¯ä¸Š
                    const angle = (i / PARTICLE_COUNT) * Math.PI * 2;
                    const radius = 4;
                    const thickness = 0.5;
                    
                    targetX = radius * Math.cos(angle);
                    targetY = radius * Math.sin(angle);
                    targetZ = (Math.random() - 0.5) * thickness;
                }
                else if (targetShape === "star") {
                    // æ˜Ÿå½¢ï¼šäº”è§’æ˜Ÿå½¢çŠ¶
                    const angle = (i / PARTICLE_COUNT) * Math.PI * 2;
                    const radius = 3 + Math.sin(angle * 5) * 0.8;
                    
                    targetX = radius * Math.cos(angle);
                    targetY = radius * Math.sin(angle);
                    targetZ = (Math.random() - 0.5) * 1.5;
                }
                else if (targetShape === "heart") {
                    // å¿ƒå½¢
                    const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                    const scale = 4;
                    
                    targetX = scale * 16 * Math.pow(Math.sin(t), 3);
                    targetY = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    targetZ = (Math.random() - 0.5) * 2;
                    
                    // è°ƒæ•´å¿ƒå½¢æ¯”ä¾‹å’Œä½ç½®
                    targetX *= 0.03;
                    targetY *= -0.03;
                    targetY += 1;
                }
                else if (targetShape === "text") {
                    // æ–‡å­—ï¼šä½¿ç”¨é¢„ç”Ÿæˆçš„ç›®æ ‡ä½ç½®
                    targetX = particleTargets[i3];
                    targetY = particleTargets[i3 + 1];
                    targetZ = particleTargets[i3 + 2];
                }
                
                // è®¡ç®—å¸å¼•åŠ›ï¼ˆæŒ‡å‘ç›®æ ‡ä½ç½®ï¼‰
                const dx = targetX - particlePositions[i3];
                const dy = targetY - particlePositions[i3 + 1];
                const dz = targetZ - particlePositions[i3 + 2];
                
                // æ ¹æ®è¿‡æ¸¡è¿›åº¦è°ƒæ•´å¸å¼•åŠ›
                const attraction = ATTRACTION_FORCE * transitionProgress;
                
                particleAccelerations[i3] += dx * attraction;
                particleAccelerations[i3 + 1] += dy * attraction;
                particleAccelerations[i3 + 2] += dz * attraction;
                
                // ç²’å­é—´æ’æ–¥åŠ›ï¼ˆé¿å…è¿‡äºå¯†é›†ï¼‰
                if (targetShape !== "text") {
                    for (let j = 0; j < Math.min(5, PARTICLE_COUNT - i); j++) {
                        const j3 = (i + j) * 3;
                        const distX = particlePositions[i3] - particlePositions[j3];
                        const distY = particlePositions[i3 + 1] - particlePositions[j3 + 1];
                        const distZ = particlePositions[i3 + 2] - particlePositions[j3 + 2];
                        const distance = Math.sqrt(distX*distX + distY*distY + distZ*distZ);
                        
                        if (distance > 0 && distance < 0.5) {
                            const repulsion = REPULSION_FORCE * (0.5 - distance) / distance;
                            particleAccelerations[i3] += distX * repulsion;
                            particleAccelerations[i3 + 1] += distY * repulsion;
                            particleAccelerations[i3 + 2] += distZ * repulsion;
                        }
                    }
                }
                
                // æ›´æ–°é€Ÿåº¦ï¼šv = v + a
                particleVelocities[i3] += particleAccelerations[i3];
                particleVelocities[i3 + 1] += particleAccelerations[i3 + 1];
                particleVelocities[i3 + 2] += particleAccelerations[i3 + 2];
                
                // åº”ç”¨é˜»å°¼
                particleVelocities[i3] *= DAMPING;
                particleVelocities[i3 + 1] *= DAMPING;
                particleVelocities[i3 + 2] *= DAMPING;
                
                // æ›´æ–°ä½ç½®ï¼šp = p + v
                particlePositions[i3] += particleVelocities[i3];
                particlePositions[i3 + 1] += particleVelocities[i3 + 1];
                particlePositions[i3 + 2] += particleVelocities[i3 + 2];
                
                // é‡ç½®åŠ é€Ÿåº¦
                particleAccelerations[i3] = 0;
                particleAccelerations[i3 + 1] = 0;
                particleAccelerations[i3 + 2] = 0;
                
                // è¾¹ç•Œé™åˆ¶ï¼ˆè½¯è¾¹ç•Œï¼‰
                const boundary = 15;
                const boundaryForce = 0.1;
                
                if (particlePositions[i3] > boundary) {
                    particleVelocities[i3] -= boundaryForce;
                } else if (particlePositions[i3] < -boundary) {
                    particleVelocities[i3] += boundaryForce;
                }
                
                if (particlePositions[i3 + 1] > boundary) {
                    particleVelocities[i3 + 1] -= boundaryForce;
                } else if (particlePositions[i3 + 1] < -boundary) {
                    particleVelocities[i3 + 1] += boundaryForce;
                }
                
                if (particlePositions[i3 + 2] > boundary) {
                    particleVelocities[i3 + 2] -= boundaryForce;
                } else if (particlePositions[i3 + 2] < -boundary) {
                    particleVelocities[i3 + 2] += boundaryForce;
                }
            }
            
            // æ ‡è®°å‡ ä½•ä½“éœ€è¦æ›´æ–°
            particlesGeometry.attributes.position.needsUpdate = true;
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°ç²’å­ç‰©ç†
            updateParticlePhysics();
            
            // æ—‹è½¬ç›¸æœºï¼ˆç¼“æ…¢è‡ªåŠ¨æ—‹è½¬ï¼‰
            camera.position.x = Math.sin(Date.now() * 0.0002) * 15;
            camera.position.z = Math.cos(Date.now() * 0.0002) * 15;
            camera.lookAt(0, 0, 0);
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }
        
        // çª—å£å¤§å°å˜åŒ–å¤„ç†
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // æ›´æ–°è¦†ç›–å±‚canvaså°ºå¯¸
            if (canvasElement) {
                canvasElement.width = window.innerWidth;
                canvasElement.height = window.innerHeight;
            }
        }
        
        // åˆå§‹åŒ–åº”ç”¨
        async function initApp() {
            try {
                // åˆå§‹åŒ–Three.js
                initThreeJS();
                
                // åˆå§‹åŒ–æ‰‹éƒ¨æ£€æµ‹
                await initHandDetection();
                
                // å¼€å§‹åŠ¨ç”»å¾ªç¯
                animate();
                
                console.log("åº”ç”¨åˆå§‹åŒ–å®Œæˆ");
            } catch (error) {
                console.error("åˆå§‹åŒ–å¤±è´¥:", error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ff5555; text-align: center;">
                        <h3>åˆå§‹åŒ–å¤±è´¥</h3>
                        <p>${error.message}</p>
                        <p>è¯·ç¡®ä¿å·²å…è®¸æ‘„åƒå¤´è®¿é—®æƒé™</p>
                        <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #0ff; border: none; border-radius: 8px; cursor: pointer;">é‡è¯•</button>
                    </div>
                `;
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–åº”ç”¨
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
