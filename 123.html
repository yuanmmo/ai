<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR Fluid Particles - å…ƒé»˜</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; 
        }
        #canvas-container { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 1; 
        }
        #video-input { 
            position: absolute; 
            top: 0; 
            left: 0; 
            opacity: 0; 
            pointer-events: none; 
            z-index: 0; 
        }
        #ui-layer {
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 10; 
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff; 
            pointer-events: none;
            user-select: none;
        }
        .loading { 
            font-size: 24px; 
            animation: pulse 1s infinite; 
        }
        .instruction { 
            font-size: 14px; 
            margin-top: 10px; 
            opacity: 0.8; 
            line-height: 1.6; 
        }
        #debug { 
            font-size: 12px; 
            margin-top: 8px;
            opacity: 0.6;
        }
        
        /* è®¾ç½®é¢æ¿ */
        #settings {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            pointer-events: auto;
        }
        
        #settings-btn {
            background: rgba(0, 0, 0, 0.5);
            color: #00ffff;
            border: 1px solid #00ffff;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #settings-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 10px #00ffff;
        }
        
        #settings-panel {
            position: absolute;
            top: 40px;
            right: 0;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 15px;
            color: #ffffff;
            font-size: 12px;
            width: 200px;
            display: none;
            backdrop-filter: blur(5px);
        }
        
        .setting-item {
            margin-bottom: 12px;
        }
        
        .setting-item label {
            display: block;
            margin-bottom: 4px;
            color: #00ffff;
        }
        
        .setting-item input[type="range"] {
            width: 100%;
            margin: 5px 0;
            -webkit-appearance: none;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
        }
        
        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
        }
        
        .value-display {
            float: right;
            color: #00ffaa;
        }
        
        /* æ€§èƒ½æŒ‡ç¤ºå™¨ */
        #fps-counter {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #00ffaa;
            font-size: 12px;
            z-index: 100;
            opacity: 0.7;
        }
        
        /* é€šçŸ¥ */
        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
            text-align: center;
        }
        
        @keyframes pulse { 
            0% { opacity: 0.5; } 
            100% { opacity: 1; } 
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
        }
        
        /* åŠ è½½åŠ¨ç”» */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid transparent;
            border-top-color: #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* éšè— MediaPipe çš„ Canvas */
        .output_canvas { display: none; }
    </style>
</head>
<body>

<!-- åŠ è½½å±å¹• -->
<div id="loading-screen">
    <div class="spinner"></div>
    <div id="loading-text" style="color: #00ffff; font-size: 18px;">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</div>
</div>

<!-- ä¸»ç•Œé¢ -->
<div id="ui-layer">
    <div id="status" class="loading">æ­£åœ¨åˆå§‹åŒ–ç¥ç»ç½‘ç»œ...</div>
    <div id="debug" class="instruction"></div>
    <div class="instruction">
        ğŸ– å¼ æ‰‹: çƒä½“ | âœŒï¸ å‰ªåˆ€: "æˆ‘æ˜¯ å…ƒé»˜" <br>
        âœŠ æ¡æ‹³: åœ†ç¯ | â˜ï¸ é£ŸæŒ‡: æ˜Ÿæ˜Ÿ <br>
        ğŸ‘ æ‹‡æŒ‡: çˆ±å¿ƒ | ğŸ‘‹ å¿«é€ŸæŒ¥æ‰‹: é£æš´
    </div>
</div>

<video id="video-input" playsinline></video>
<div id="canvas-container"></div>

<!-- è®¾ç½®é¢æ¿ -->
<div id="settings">
    <button id="settings-btn">âš™ï¸ è®¾ç½®</button>
    <div id="settings-panel">
        <div class="setting-item">
            <label>ç²’å­æ•°é‡: <span class="value-display" id="particle-count-value">16000</span></label>
            <input type="range" id="particle-count" min="2000" max="30000" step="1000" value="16000">
        </div>
        <div class="setting-item">
            <label>ç²’å­å¤§å°: <span class="value-display" id="particle-size-value">0.15</span></label>
            <input type="range" id="particle-size" min="0.05" max="0.5" step="0.01" value="0.15">
        </div>
        <div class="setting-item">
            <label>å¼¹åŠ›å¼ºåº¦: <span class="value-display" id="spring-value">0.05</span></label>
            <input type="range" id="spring-strength" min="0.01" max="0.2" step="0.01" value="0.05">
        </div>
        <div class="setting-item">
            <label>é¢œè‰²å¼ºåº¦: <span class="value-display" id="color-intensity-value">1.0</span></label>
            <input type="range" id="color-intensity" min="0.1" max="2.0" step="0.1" value="1.0">
        </div>
        <div class="setting-item">
            <button id="reset-btn" style="width:100%; padding:5px; background:#333; color:#fff; border:1px solid #00ffff; border-radius:4px;">é‡ç½®é»˜è®¤è®¾ç½®</button>
        </div>
    </div>
</div>

<!-- FPSè®¡æ•°å™¨ -->
<div id="fps-counter">FPS: 60</div>

<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // --- é…ç½®å‚æ•° ---
    const CONFIG = {
        particleCount: 16000,
        color: 0x00ffff,
        particleSize: 0.15,
        springStrength: 0.05,
        friction: 0.92,
        explosionForce: 0.5,
        stormThreshold: 30,
        stormForce: 2.0,
        baseDepth: 20,
        colorIntensity: 1.0
    };

    // --- å…¨å±€å˜é‡ ---
    let scene, camera, renderer, particlesMesh;
    let targetPositions = [];
    let currentPositions, velocities;
    let shapeCache = {};
    let currentShape = 'sphere';
    let handLandmarks = null;
    let handSpeed = 0;
    let lastHandPos = new THREE.Vector3();
    let isExploding = false;
    let handSizeFactor = 1;
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 60;
    let particlesNeedReset = false;
    let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

    // DOM å…ƒç´ 
    const container = document.getElementById('canvas-container');
    const statusEl = document.getElementById('status');
    const debugEl = document.getElementById('debug');
    const fpsCounter = document.getElementById('fps-counter');
    const loadingScreen = document.getElementById('loading-screen');
    const loadingText = document.getElementById('loading-text');

    // --- åˆå§‹åŒ– Three.js ---
    function initThree() {
        try {
            // æ ¹æ®è®¾å¤‡è°ƒæ•´é…ç½®
            if (isMobile) {
                CONFIG.particleCount = 8000;
                CONFIG.particleSize = 0.2;
                loadingText.textContent = "ç§»åŠ¨ç«¯ä¼˜åŒ–æ¨¡å¼...";
            }

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.baseDepth;

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
            container.appendChild(renderer.domElement);

            createParticles();
            precomputeShapes();
            
            window.addEventListener('resize', onWindowResize);
            
            // æ·»åŠ çª—å£å¤±å»ç„¦ç‚¹æ—¶æš‚åœåŠ¨ç”»
            window.addEventListener('blur', () => {
                isPaused = true;
            });
            
            window.addEventListener('focus', () => {
                isPaused = false;
                lastTime = performance.now(); // é‡ç½®æ—¶é—´è®¡ç®—
            });
            
            updateLoadingProgress("Three.js åˆå§‹åŒ–å®Œæˆ", 30);
            
        } catch (error) {
            console.error("Three.js åˆå§‹åŒ–å¤±è´¥:", error);
            showError("3D æ¸²æŸ“å¼•æ“åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚");
        }
    }

    // --- åˆ›å»ºç²’å­ç³»ç»Ÿ ---
    function createParticles() {
        const geometry = new THREE.BufferGeometry();
        currentPositions = new Float32Array(CONFIG.particleCount * 3);
        velocities = new Float32Array(CONFIG.particleCount * 3);
        
        // åˆå§‹åŒ–éšæœºä½ç½®
        for (let i = 0; i < CONFIG.particleCount * 3; i++) {
            currentPositions[i] = (Math.random() - 0.5) * 50;
            velocities[i] = 0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

        // ç”Ÿæˆåœ†å½¢ç²’å­çº¹ç†
        const sprite = generateSprite();

        const material = new THREE.PointsMaterial({
            color: CONFIG.color,
            size: CONFIG.particleSize,
            map: sprite,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        particlesMesh = new THREE.Points(geometry, material);
        scene.add(particlesMesh);
    }

    function generateSprite() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.4, 'rgba(0,255,255,0.5)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        context.fillStyle = gradient;
        context.fillRect(0,0,32,32);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    // --- é¢„è®¡ç®—æ‰€æœ‰å½¢çŠ¶ ---
    function precomputeShapes() {
        updateLoadingProgress("æ­£åœ¨ç”Ÿæˆå½¢çŠ¶...", 40);
        
        // ä½¿ç”¨ä¼˜åŒ–çš„ç®—æ³•
        shapeCache.sphere = getSpherePointsOptimized(CONFIG.particleCount, 8);
        shapeCache.torus = getTorusPoints(CONFIG.particleCount, 7, 2.5);
        shapeCache.star = getStarPointsOptimized(CONFIG.particleCount, 8, 3);
        shapeCache.heart = getHeartPointsOptimized(CONFIG.particleCount, 0.5);
        shapeCache.text = getTextPoints("æˆ‘æ˜¯\nå…ƒé»˜", CONFIG.particleCount);

        targetPositions = shapeCache.sphere;
        
        updateLoadingProgress("å½¢çŠ¶ç”Ÿæˆå®Œæˆ", 60);
    }

    // ä¼˜åŒ–çš„çƒä½“ç‚¹ç”Ÿæˆ
    function getSpherePointsOptimized(count, radius) {
        const arr = new Float32Array(count * 3);
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));
        
        for (let i = 0; i < count; i++) {
            const y = 1 - (i / (count - 1)) * 2;
            const radiusAtY = radius * Math.sqrt(1 - y * y);
            const theta = goldenAngle * i;
            
            arr[i*3] = radiusAtY * Math.cos(theta);
            arr[i*3+1] = radius * y;
            arr[i*3+2] = radiusAtY * Math.sin(theta);
        }
        return arr;
    }

    function getTorusPoints(count, R, r) {
        const arr = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI * 2;
            arr[i*3] = (R + r * Math.cos(v)) * Math.cos(u);
            arr[i*3+1] = (R + r * Math.cos(v)) * Math.sin(u);
            arr[i*3+2] = r * Math.sin(v);
        }
        return arr;
    }

    // ä¼˜åŒ–çš„æ˜Ÿæ˜Ÿç‚¹ç”Ÿæˆ
    function getStarPointsOptimized(count, outerR, innerR) {
        const arr = new Float32Array(count * 3);
        const points = 5; // äº”è§’æ˜Ÿ
        
        for(let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const segment = Math.PI * 2 / points;
            const k = Math.floor(angle / segment);
            
            // è®¡ç®—æ˜Ÿå½¢åŠå¾„
            const localAngle = angle - k * segment;
            const t = localAngle / (segment / 2);
            const r = t < 1 ? outerR : innerR;
            
            const finalAngle = k * segment + (t < 1 ? t * segment / 2 : segment / 2 + (t - 1) * segment / 2);
            
            arr[i*3] = r * Math.cos(finalAngle) * 2;
            arr[i*3+1] = r * Math.sin(finalAngle) * 2;
            arr[i*3+2] = (Math.random() - 0.5) * 2;
        }
        return arr;
    }

    // ä¼˜åŒ–çš„çˆ±å¿ƒç‚¹ç”Ÿæˆ
    function getHeartPointsOptimized(count, scale) {
        const arr = new Float32Array(count * 3);
        let generated = 0;
        
        // ä½¿ç”¨å‚æ•°æ–¹ç¨‹æ›´é«˜æ•ˆåœ°ç”Ÿæˆçˆ±å¿ƒ
        while (generated < count) {
            const t = Math.random() * Math.PI * 2;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            
            // æ·»åŠ éšæœºæ·±åº¦
            const z = (Math.random() - 0.5) * 3;
            
            arr[generated*3] = x * 0.5 * scale;
            arr[generated*3+1] = -y * 0.5 * scale + 2;
            arr[generated*3+2] = z;
            
            generated++;
        }
        return arr;
    }

    function getTextPoints(text, count) {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000000';
        ctx.fillRect(0,0,1024,1024);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 200px "Microsoft YaHei", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const lines = text.split('\n');
        lines.forEach((line, idx) => {
            ctx.fillText(line, 512, 400 + idx * 220);
        });

        const imageData = ctx.getImageData(0, 0, 1024, 1024);
        const data = imageData.data;
        const validPixels = [];

        // é‡‡æ ·åƒç´ 
        for(let y = 0; y < 1024; y += 4) {
            for(let x = 0; x < 1024; x += 4) {
                const index = (y * 1024 + x) * 4;
                if(data[index] > 128) {
                    validPixels.push({x: (x - 512) / 30, y: -(y - 512) / 30});
                }
            }
        }

        const arr = new Float32Array(count * 3);
        for(let i = 0; i < count; i++) {
            const p = validPixels[i % validPixels.length] || {x:0, y:0};
            arr[i*3] = p.x + (Math.random() - 0.5) * 0.2;
            arr[i*3+1] = p.y + (Math.random() - 0.5) * 0.2;
            arr[i*3+2] = (Math.random() - 0.5) * 1;
        }
        return arr;
    }

    // --- åŠ¨ç”»å¾ªç¯ ---
    let lastFrameTime = performance.now();
    let isPaused = false;
    const PHYSICS_TIMESTEP = 1000 / 60; // 60Hz ç‰©ç†æ›´æ–°

    function animate(currentTime) {
        requestAnimationFrame(animate);
        
        if (isPaused) return;
        
        const deltaTime = Math.min(currentTime - lastFrameTime, 100); // é™åˆ¶æœ€å¤§deltaTime
        lastFrameTime = currentTime;
        
        // æ›´æ–°FPSè®¡æ•°å™¨
        frameCount++;
        if (currentTime - lastTime >= 1000) {
            fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
            fpsCounter.textContent = `FPS: ${fps}`;
            frameCount = 0;
            lastTime = currentTime;
        }
        
        // ç²’å­ç‰©ç†æ›´æ–°
        updateParticlesPhysics(deltaTime);
        
        // æ›´æ–°æ¸²æŸ“
        particlesMesh.rotation.y += 0.001;
        particlesMesh.rotation.z += 0.0005;
        
        renderer.render(scene, camera);
        
        // å¤„ç†ç²’å­ç³»ç»Ÿé‡ç½®
        if (particlesNeedReset) {
            resetParticleSystem();
            particlesNeedReset = false;
        }
    }

    function updateParticlesPhysics(deltaTime) {
        const positions = particlesMesh.geometry.attributes.position.array;
        const timeFactor = deltaTime / PHYSICS_TIMESTEP;
        
        // æ‰‹éƒ¨äº¤äº’è®¡ç®—
        let handX = 0, handY = 0;
        let isStorming = false;

        if (handLandmarks) {
            const palm = handLandmarks[9];
            const aspect = window.innerWidth / window.innerHeight;
            handX = (0.5 - palm.x) * 30 * aspect;
            handY = (0.5 - palm.y) * 30;
            
            // é£æš´é€»è¾‘
            if (handSpeed > CONFIG.stormThreshold) {
                isStorming = true;
            }
            
            // è®¡ç®—æ·±åº¦ç¼©æ”¾
            const dist = Math.hypot(handLandmarks[0].x - handLandmarks[9].x, 
                                   handLandmarks[0].y - handLandmarks[9].y);
            const targetScale = 0.5 + dist * 3;
            handSizeFactor = handSizeFactor * 0.9 + targetScale * 0.1;
        } else {
            handSizeFactor = handSizeFactor * 0.95 + 1.0 * 0.05;
        }

        // åˆ†æ‰¹å¤„ç†ç²’å­ä»¥æé«˜æ€§èƒ½
        const BATCH_SIZE = isMobile ? 200 : 500;
        const startIdx = Math.floor((performance.now() / 100) % (CONFIG.particleCount / BATCH_SIZE)) * BATCH_SIZE;
        
        for (let i = 0; i < BATCH_SIZE; i++) {
            const idx = ((startIdx + i) % CONFIG.particleCount) * 3;
            
            let px = positions[idx];
            let py = positions[idx+1];
            let pz = positions[idx+2];

            let vx = velocities[idx];
            let vy = velocities[idx+1];
            let vz = velocities[idx+2];

            // ç›®æ ‡å¸å¼•åŠ›
            let tx = targetPositions[idx] * handSizeFactor;
            let ty = targetPositions[idx+1] * handSizeFactor;
            let tz = targetPositions[idx+2] * handSizeFactor;

            let ax = (tx - px) * CONFIG.springStrength * timeFactor;
            let ay = (ty - py) * CONFIG.springStrength * timeFactor;
            let az = (tz - pz) * CONFIG.springStrength * timeFactor;

            // é£æš´äº¤äº’
            if (isStorming) {
                const dx = px - handX;
                const dy = py - handY;
                const distSq = dx*dx + dy*dy;
                if (distSq < 100) {
                    const force = CONFIG.stormForce / (distSq + 0.1) * timeFactor;
                    ax += dx * force * 2;
                    ay += dy * force * 2;
                    az += (Math.random() - 0.5) * force * 5;
                }
            }

            // çˆ†ç‚¸è¿‡æ¸¡
            if (isExploding) {
                vx += (Math.random() - 0.5) * CONFIG.explosionForce * 10 * timeFactor;
                vy += (Math.random() - 0.5) * CONFIG.explosionForce * 10 * timeFactor;
                vz += (Math.random() - 0.5) * CONFIG.explosionForce * 10 * timeFactor;
            }

            // ç§¯åˆ†æ›´æ–°
            vx += ax;
            vy += ay;
            vz += az;

            vx *= Math.pow(CONFIG.friction, timeFactor);
            vy *= Math.pow(CONFIG.friction, timeFactor);
            vz *= Math.pow(CONFIG.friction, timeFactor);

            positions[idx]   += vx;
            positions[idx+1] += vy;
            positions[idx+2] += vz;

            velocities[idx]   = vx;
            velocities[idx+1] = vy;
            velocities[idx+2] = vz;
        }

        if (isExploding) isExploding = false;
        
        particlesMesh.geometry.attributes.position.needsUpdate = true;
    }

    // --- MediaPipe Hands é›†æˆ ---
    async function initMediaPipe() {
        try {
            updateLoadingProgress("æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...", 70);
            
            // åŠ¨æ€åŠ è½½ MediaPipe
            await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js');
            await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');
            
            updateLoadingProgress("æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...", 85);
            
            const videoElement = document.getElementById('video-input');
            
            const hands = new window.Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: isMobile ? 0 : 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const camera = new window.Camera(videoElement, {
                onFrame: async () => {
                    try {
                        await hands.send({image: videoElement});
                    } catch (e) {
                        console.warn("Camera frame processing error:", e);
                    }
                },
                width: 640,
                height: 480
            });

            await camera.start();
            
            updateLoadingProgress("ç³»ç»Ÿå°±ç»ª", 100);
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 1000);
            }, 500);
            
            statusEl.textContent = "ç³»ç»Ÿå°±ç»ª - è¯·å±•ç¤ºæ‰‹åŠ¿";
            statusEl.style.color = "#00ff00";
            setTimeout(() => { 
                statusEl.style.display = 'none'; 
            }, 3000);
            
        } catch (error) {
            console.error("MediaPipe åˆå§‹åŒ–å¤±è´¥:", error);
            showError("æ‘„åƒå¤´æˆ–æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™ã€‚");
        }
    }

    function loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    // --- æ‰‹åŠ¿è¯†åˆ«ä¸å¤„ç† ---
    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handLandmarks = results.multiHandLandmarks[0];
            
            // è®¡ç®—æ‰‹é€Ÿ
            const wrist = handLandmarks[0];
            const currentVec = new THREE.Vector3(wrist.x, wrist.y, wrist.z);
            const speed = currentVec.distanceTo(lastHandPos) / 0.033;
            handSpeed = handSpeed * 0.8 + speed * 0.2;
            lastHandPos.copy(currentVec);

            // è¯†åˆ«æ‰‹åŠ¿
            const detectedGesture = detectGestureEnhanced(handLandmarks);
            
            // æ›´æ–°è°ƒè¯•ä¿¡æ¯
            if (debugEl) {
                debugEl.innerHTML = `
                    æ‰‹åŠ¿: ${currentShape.toUpperCase()} | 
                    é€Ÿåº¦: ${handSpeed.toFixed(1)} | 
                    ç¼©æ”¾: ${handSizeFactor.toFixed(2)}
                `;
            }
            
            // è§¦å‘å½¢çŠ¶åˆ‡æ¢
            if (detectedGesture && detectedGesture !== currentShape) {
                changeShape(detectedGesture);
            }
        } else {
            handLandmarks = null;
            handSpeed = 0;
        }
    }

    function detectGestureEnhanced(lm) {
        // æ”¹è¿›çš„æ‰‹åŠ¿æ£€æµ‹ç®—æ³•
        const fingerIndices = [
            {tip: 4, pip: 3, mcp: 2},  // æ‹‡æŒ‡
            {tip: 8, pip: 6, mcp: 5},  // é£ŸæŒ‡
            {tip: 12, pip: 10, mcp: 9}, // ä¸­æŒ‡
            {tip: 16, pip: 14, mcp: 13}, // æ— åæŒ‡
            {tip: 20, pip: 18, mcp: 17}  // å°æŒ‡
        ];

        // è®¡ç®—æ¯ä¸ªæ‰‹æŒ‡çš„ä¼¸ç›´çŠ¶æ€
        const fingerStates = fingerIndices.map(({tip, pip, mcp}) => {
            // ä½¿ç”¨å‘é‡ç‚¹ç§¯åˆ¤æ–­ä¼¸ç›´ç¨‹åº¦
            const tipToMCP = new THREE.Vector3(lm[tip].x - lm[mcp].x, lm[tip].y - lm[mcp].y, lm[tip].z - lm[mcp].z);
            const pipToMCP = new THREE.Vector3(lm[pip].x - lm[mcp].x, lm[pip].y - lm[mcp].y, lm[pip].z - lm[mcp].z);
            
            // è®¡ç®—å¤¹è§’ä½™å¼¦å€¼
            const dot = tipToMCP.dot(pipToMCP);
            const tipLength = tipToMCP.length();
            const pipLength = pipToMCP.length();
            const cosAngle = dot / (tipLength * pipLength + 0.0001);
            
            // å¦‚æœå¤¹è§’å°äº45åº¦ï¼ˆä½™å¼¦å€¼ > 0.707ï¼‰ï¼Œè®¤ä¸ºæ‰‹æŒ‡æ˜¯ä¼¸ç›´çš„
            return cosAngle > 0.3; // ç¨å¾®å®½æ¾ä¸€äº›çš„é˜ˆå€¼
        });

        const [thumb, index, middle, ring, pinky] = fingerStates;

        // æ‰‹åŠ¿åˆ¤æ–­
        if (!index && !middle && !ring && !pinky) {
            return thumb ? 'heart' : 'torus';
        } else if (index && middle && !ring && !pinky) {
            return 'text';
        } else if (index && !middle && !ring && !pinky) {
            return 'star';
        } else if (index && middle && ring && pinky) {
            return 'sphere';
        }
        
        return currentShape; // å¦‚æœæ²¡æœ‰åŒ¹é…ï¼Œä¿æŒå½“å‰å½¢çŠ¶
    }

    function changeShape(shapeName) {
        if (shapeCache[shapeName] && shapeName !== currentShape) {
            // è§†è§‰åé¦ˆ
            particlesMesh.material.opacity = 0.3;
            setTimeout(() => {
                particlesMesh.material.opacity = 0.8;
            }, 100);
            
            targetPositions = shapeCache[shapeName];
            currentShape = shapeName;
            isExploding = true;
            
            // æ˜¾ç¤ºé€šçŸ¥
            showNotification(shapeName);
        }
    }

    // --- UI åŠŸèƒ½ ---
    function showNotification(shape) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = `åˆ‡æ¢åˆ°: ${getShapeName(shape)}`;
        
        document.body.appendChild(notification);
        
        // è§¦å‘åŠ¨ç”»
        setTimeout(() => {
            notification.style.animation = 'fadeInOut 2s ease forwards';
        }, 10);
        
        // æ¸…ç†
        setTimeout(() => {
            notification.remove();
        }, 2100);
    }

    function getShapeName(shape) {
        const names = {
            'sphere': 'çƒä½“',
            'torus': 'åœ†ç¯',
            'star': 'æ˜Ÿæ˜Ÿ',
            'heart': 'çˆ±å¿ƒ',
            'text': 'æ–‡å­—'
        };
        return names[shape] || shape;
    }

    function showError(message) {
        statusEl.textContent = message;
        statusEl.style.color = '#ff5555';
        statusEl.style.display = 'block';
    }

    function updateLoadingProgress(message, progress) {
        if (loadingText) {
            loadingText.textContent = `${message} (${progress}%)`;
        }
    }

    // --- è®¾ç½®é¢æ¿åŠŸèƒ½ ---
    function initSettingsPanel() {
        const settingsBtn = document.getElementById('settings-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const resetBtn = document.getElementById('reset-btn');
        
        settingsBtn.addEventListener('click', () => {
            settingsPanel.style.display = settingsPanel.style.display === 'block' ? 'none' : 'block';
        });
        
        // å…³é—­è®¾ç½®é¢æ¿å½“ç‚¹å‡»å¤–éƒ¨
        document.addEventListener('click', (e) => {
            if (!settingsPanel.contains(e.target) && e.target !== settingsBtn) {
                settingsPanel.style.display = 'none';
            }
        });
        
        // ç²’å­æ•°é‡æ§åˆ¶
        const particleCountSlider = document.getElementById('particle-count');
        const particleCountValue = document.getElementById('particle-count-value');
        
        particleCountSlider.addEventListener('input', (e) => {
            const newValue = parseInt(e.target.value);
            particleCountValue.textContent = newValue.toLocaleString();
        });
        
        particleCountSlider.addEventListener('change', (e) => {
            CONFIG.particleCount = parseInt(e.target.value);
            particlesNeedReset = true;
        });
        
        // ç²’å­å¤§å°æ§åˆ¶
        const particleSizeSlider = document.getElementById('particle-size');
        const particleSizeValue = document.getElementById('particle-size-value');
        
        particleSizeSlider.addEventListener('input', (e) => {
            const newValue = parseFloat(e.target.value).toFixed(2);
            particleSizeValue.textContent = newValue;
            CONFIG.particleSize = parseFloat(newValue);
            particlesMesh.material.size = CONFIG.particleSize;
        });
        
        // å¼¹åŠ›å¼ºåº¦æ§åˆ¶
        const springSlider = document.getElementById('spring-strength');
        const springValue = document.getElementById('spring-value');
        
        springSlider.addEventListener('input', (e) => {
            const newValue = parseFloat(e.target.value).toFixed(2);
            springValue.textContent = newValue;
            CONFIG.springStrength = parseFloat(newValue);
        });
        
        // é¢œè‰²å¼ºåº¦æ§åˆ¶
        const colorSlider = document.getElementById('color-intensity');
        const colorValue = document.getElementById('color-intensity-value');
        
        colorSlider.addEventListener('input', (e) => {
            const newValue = parseFloat(e.target.value).toFixed(1);
            colorValue.textContent = newValue;
            CONFIG.colorIntensity = parseFloat(newValue);
            particlesMesh.material.opacity = 0.8 * CONFIG.colorIntensity;
        });
        
        // é‡ç½®æŒ‰é’®
        resetBtn.addEventListener('click', () => {
            const defaults = {
                particleCount: 16000,
                particleSize: 0.15,
                springStrength: 0.05,
                colorIntensity: 1.0
            };
            
            // é‡ç½®æ»‘å—
            particleCountSlider.value = defaults.particleCount;
            particleSizeSlider.value = defaults.particleSize;
            springSlider.value = defaults.springStrength;
            colorSlider.value = defaults.colorIntensity;
            
            // æ›´æ–°æ˜¾ç¤º
            particleCountValue.textContent = defaults.particleCount.toLocaleString();
            particleSizeValue.textContent = defaults.particleSize.toFixed(2);
            springValue.textContent = defaults.springStrength.toFixed(2);
            colorValue.textContent = defaults.colorIntensity.toFixed(1);
            
            // æ›´æ–°é…ç½®
            Object.assign(CONFIG, defaults);
            
            // åº”ç”¨æ›´æ”¹
            particlesNeedReset = true;
            particlesMesh.material.size = CONFIG.particleSize;
            particlesMesh.material.opacity = 0.8 * CONFIG.colorIntensity;
        });
        
        // åˆå§‹åŒ–æ˜¾ç¤ºå€¼
        particleCountValue.textContent = CONFIG.particleCount.toLocaleString();
        particleSizeValue.textContent = CONFIG.particleSize.toFixed(2);
        springValue.textContent = CONFIG.springStrength.toFixed(2);
        colorValue.textContent = CONFIG.colorIntensity.toFixed(1);
    }

    function resetParticleSystem() {
        // åˆ›å»ºæ–°çš„å‡ ä½•ä½“
        const newGeometry = new THREE.BufferGeometry();
        const newPositions = new Float32Array(CONFIG.particleCount * 3);
        const newVelocities = new Float32Array(CONFIG.particleCount * 3);
        
        // å¤åˆ¶ç°æœ‰æ•°æ®æˆ–åˆå§‹åŒ–æ–°æ•°æ®
        const copyCount = Math.min(CONFIG.particleCount, currentPositions.length / 3);
        
        for (let i = 0; i < copyCount * 3; i++) {
            newPositions[i] = currentPositions[i] || (Math.random() - 0.5) * 50;
            newVelocities[i] = velocities[i] || 0;
        }
        
        // å¦‚æœå¢åŠ äº†ç²’å­æ•°é‡ï¼Œåˆå§‹åŒ–æ–°å¢ç²’å­
        for (let i = copyCount * 3; i < CONFIG.particleCount * 3; i++) {
            newPositions[i] = (Math.random() - 0.5) * 50;
            newVelocities[i] = 0;
        }
        
        newGeometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
        
        // æ›¿æ¢å‡ ä½•ä½“
        particlesMesh.geometry.dispose();
        particlesMesh.geometry = newGeometry;
        
        // æ›´æ–°å¼•ç”¨
        currentPositions = newPositions;
        velocities = newVelocities;
        
        // é‡æ–°é¢„è®¡ç®—å½¢çŠ¶
        precomputeShapes();
    }

    // --- çª—å£è°ƒæ•´å¤§å° ---
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- è§¦æ‘¸è®¾å¤‡æ”¯æŒ ---
    function initTouchSupport() {
        if ('ontouchstart' in window) {
            let touchStartTime = 0;
            let touchStartX = 0;
            let touchStartY = 0;
            
            container.addEventListener('touchstart', (e) => {
                touchStartTime = Date.now();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                
                // äº”æŒ‡å¼ å¼€åˆ‡æ¢çƒä½“
                if (e.touches.length === 5) {
                    changeShape('sphere');
                }
            });
            
            container.addEventListener('touchend', (e) => {
                const touchDuration = Date.now() - touchStartTime;
                if (touchDuration < 200) {
                    isExploding = true;
                }
            });
            
            container.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    const touchX = e.touches[0].clientX;
                    const touchY = e.touches[0].clientY;
                    
                    // æ¨¡æ‹Ÿæ‰‹éƒ¨ä½ç½®
                    const normalizedX = (touchX / window.innerWidth - 0.5) * 30;
                    const normalizedY = (0.5 - touchY / window.innerHeight) * 30;
                    
                    // å¦‚æœæ²¡æœ‰æ‘„åƒå¤´è¾“å…¥ï¼Œä½¿ç”¨è§¦æ‘¸ä½ç½®
                    if (!handLandmarks) {
                        handLandmarks = [{x: 0.5, y: 0.5, z: 0}];
                        handLandmarks[9] = {
                            x: 0.5 + normalizedX / (30 * (window.innerWidth / window.innerHeight)),
                            y: 0.5 + normalizedY / 30,
                            z: 0
                        };
                    }
                }
            });
        }
    }

    // --- å¯åŠ¨ç¨‹åº ---
    async function init() {
        try {
            updateLoadingProgress("æ­£åœ¨åˆå§‹åŒ–3Då¼•æ“...", 10);
            initThree();
            
            updateLoadingProgress("æ­£åœ¨åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢...", 20);
            initSettingsPanel();
            initTouchSupport();
            
            // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            requestAnimationFrame(animate);
            
            // åˆå§‹åŒ–MediaPipe
            await initMediaPipe();
            
            console.log("WebAR Fluid Particles å¯åŠ¨æˆåŠŸï¼");
            
        } catch (error) {
            console.error("åˆå§‹åŒ–å¤±è´¥:", error);
            showError("ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚");
        }
    }

    // å¯åŠ¨åº”ç”¨
    init();

</script>
</body>
</html>
